module astr/runtime/annotations

imports
  libstratego-lib
  astr/runtime/parents
  astr/runtime/lists
  astr/runtime/attributes

strategies // Util

  debug'(s) = where(strip-annos; debug(s))

  debug' = where(strip-annos; debug)
  
  with'(s) =
    s
  <+
    astr-remove-annos;
    log(|Critical(), "Internal error: with clause failed unexpectedly", <id>);
    prim("SSL_stacktrace_get_all_frame_names");
    report-failure
  
  // TODO2: Optimize - eq-ignore-annos is expensive
  
  eq-ignore-annos(|term) =
    ?term
  <+
    where( // cheapish base check, must at least pass this
      input-ctor := <get-constructor>{};
      term-ctor  := <get-constructor> term{};
      ?input-ctor
    );
    where(
      term' := <astr-remove-annos> term
    );
    where(
      ?term' <+ astr-remove-annos => term'
    )
  
  is-astr-initialized(|all-parents) = where(get-parent(|all-parents))
  
  astr-remove-annos-persist(|attr-cache) =
    astr-remove-annos;
    set-keep-uninitialized(|attr-cache, <id>)
  
  astr-node-path(|parent, all-parents, attr-cache) =
    if is-astr-initialized(|all-parents) then
      eval-path-and-node(|parent, all-parents, attr-cache, 0)
    else
      <conc-strings> ("?", ".", <to-tiny-string>)
    end
  
  eval-path-and-node(|parent, all-parents, attr-cache, rewrite-mode) =
    fail // generator-defined rule

strategies // Node initialization

  // TODO: Use an "uninit" annotation instead of get-keep-uninitialized, its overhead, and possible bugs because of it...

  /**
   * Initialize an attribute value.
   *
   * Attribute values are like any other node, but can explicitly be marked
   * as uninitialized (using id.uninit / astr-remove-annos-persist).
   * Additionally, attribute values may be lists or tuples of reference
   * values.
   */
  astr-initialize-attribute-value(|all-parents, attr-cache) =
    get-keep-uninitialized(|attr-cache, <id>)
  <+
    // TODO: What if the user was building a standard list?
    // Support reference collections
    map(astr-initialize-node-ensure(|all-parents, attr-cache))
  <+
    where(get-constructor => ""); // is-tuple
    all(astr-initialize-node-ensure(|all-parents, attr-cache))
  <+
    astr-initialize-node-ensure(|all-parents, attr-cache)
  
  /**
   * Initialize a node if it was not yet initialized.
   */
  astr-initialize-node-ensure(|all-parents, attr-cache) =
    astr-initialize-node-ensure(id|all-parents, attr-cache)

  astr-initialize-node-ensure(warning|all-parents, attr-cache) =
    if not(is-astr-initialized(|all-parents)) then
      where(warning);    
      astr-initialize-node(|all-parents, attr-cache)
    end

  astr-initialize-node-warning(|all-parents, attribute) =
    if not(AstrWarningsDisabled <+ astr-is-reference-collection(|all-parents)) then
      warn(|["Evaluating attribute '", attribute, "' on an uninitialized term"]);
      prim("SSL_stacktrace_get_all_frame_names");
      try(\["astr_initialize_node_warning_0_0" | tail] -> tail\);
      try(\["astr_initialize_node_ensure_1_1" | tail] -> tail\);
      reverse;
      map(<fprintnl> (stderr(), ["\t", <id>]))
    end
  
  internal-enable-warnings =
    rules(AstrWarningsDisabled :- _) // ensure this rule is defined somewhere
  
  astr-is-reference-collection(|all-parents) = 
    (is-list + is-tuple);
    all(is-astr-initialized(|all-parents))
  
  astr-initialize-node-no-rewrite(|all-parents) =
    astr-initialize-node-no-rewrite(|all-parents, NoParent())
  
  astr-initialize-node-no-rewrite(|all-parents, parent) =
    // First add unique annos everywhere,
    // then assign parent rules for the newly formed nodes
    ?node;
    astr-add-annos;
    where(
      astr-add-parent-references(|all-parents, parent)
    )

strategies // Adding/removing node annotations
  
  astr-add-annos =
    leaves-consnil(astr-add-anno)

  astr-add-anno:
    t {a*} -> t {b*}
    where
      if [] := a* then
        b* := [<newname> "@"]
      else
        b* := [<newname> "@" | <filter(not(is-astr-annotation))> a*]
      end
  
  astr-remove-annos =
    // leaves-consnil should suffice in most cases, but this
    // should handle more at about the same overhead
    topdown-consnil(astr-remove-anno)
  
  astr-remove-anno =
    try(
      \t {<is-astr-annotation>} -> t {}\
    <+
      ?_{}
    <+
      \t {a*} -> t {b*}
       where
         b* := <filter(not(is-astr-annotation))> a*\
    )
  
  is-astr-annotation =
    is-string
    // TODO: Is this a sensible optimization?
    // ; explode-string => ['@' | _] 

strategies // Hash table storage for init/uninit

  /* UNDONE: Caching of node initialization
  
  // Caching of node initialization ensured:
  // - caching of attributes accross tree copies and rewrites of complete trees
  //   (but attribute caching and rewrite caching mostly takes care of that)
  // - cheap equality checks after every rewrite or circular evaluation
  //   (not really, unless you add an expensive remove-annos before caching)

  get-initialize-cache(|attr-cache, parent, node) =
    where(NoParent() := parent);
    get-cached-attribute(|attr-cache, node, "$inited")
 
  set-initialize-cache(|attr-cache, parent, node, value) =
    not(NoParent() := parent) // no caching for you
  <+
    set-cached-attribute(|attr-cache, node, "$inited", value)
  */

  get-keep-uninitialized(|attr-cache, node) =
    get-cached-attribute(|attr-cache, node, "$uninited")
 
  set-keep-uninitialized(|attr-cache, node) =
    set-cached-attribute(|attr-cache, node, "$uninited", node)
    
