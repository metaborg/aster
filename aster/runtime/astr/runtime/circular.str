/**
 * Circular attribute evaluation run-time.
 * Uses the attribute cache table to store a worklist.
 *
 * @internal
 * @author Lennart Kats <lennart add lclnet.nl>
 */
module astr/runtime/circular

imports
  libstratego-lib
  astr/runtime/hashtables

signature constructors
  CIRCULAR_FINISHED : Term -> Term
  CIRCULAR_BUSY     : Term -> Term

strategies

  // TODO: Start a new fixpoint for a new strongly connected component? (helps performance and prevents premature caching)
  //       or could we give an error for attributes apply premature caching during circular fixpoint?

  circular-fixpoint(eval : t * a -> a |attr-cache, initial) =
    if circular-enter-fixpoint(|attr-cache) then
      ?fixpoint-locked
    end;
  
    ?node;
    eval(|initial);

    if !fixpoint-locked then
      while(
        circular-get-remove-has-changed(|attr-cache)
      ,
        circular-reset-participants(|attr-cache);
          
        { old-value:
          ?old-value;
          <eval(|old-value)> node
        }
      );
      
      circular-mark-participants-finished(|attr-cache); // also resets
      circular-exit-fixpoint(|attr-cache);
      not(EVAL_FAILED)
    end

strategies // Maintain a list of attributes participating in the latest fixpoint network

  // We maintain a set of all unchanged attributes in the last evaluation;
  // _only_ these will surely reach fixpoint once the iteration is complete.
  circular-add-participant(|attr-cache, node, name-args, value) =
    where(
      ( hashtable-get(|attr-cache, "$circular-unchanged")
      <+
        new-iset;
        hashtable-put(|attr-cache, "$circular-unchanged", <new-iset>)
      );
      iset-add(|(node, name-args, value))
    )
  
  circular-mark-participants-finished(|attr-cache) =
    where(
      hashtable-get(|attr-cache, "$circular-unchanged") => set;
      iset-elements;
      
      list-loop(
        { node, name-args, value:
          ?(node, name-args, value);
          set-cached-attribute(|attr-cache, node, name-args, CIRCULAR_FINISHED(value))
        }
      );
      
      <iset-clear> set
    )

  circular-reset-participants(|attr-cache) =
    where(try(
      hashtable-get(|attr-cache, "$circular-unchanged");
      iset-clear
    ))

strategies // Only one fixpoint loop runs at a time

  circular-enter-fixpoint(|attr-cache) =
    not(hashtable-get(|attr-cache, "$circular-lock"));
    hashtable-put(|attr-cache, "$circular-lock", ())

  circular-exit-fixpoint(|attr-cache) =
    hashtable-remove(|attr-cache, "$circular-lock")

strategies // Fixpoint keeps running while something changed
  
  circular-set-has-changed(|attr-cache) =
    hashtable-put(|attr-cache, "$circular-changed", ())
  
  circular-get-remove-has-changed(|attr-cache) =
    where(hashtable-get(|attr-cache, "$circular-changed"));
    hashtable-remove(|attr-cache, "$circular-changed")
