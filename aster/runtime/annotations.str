module annotations

imports
  libstratego-lib
  parents
  lists

strategies // Util

  debug'(s) = where(strip-annos; debug(s))

  debug' = where(strip-annos; debug)
  
  is-astr-annotation =
    explode-string => ['@' | _]
  
  eq-ignore-annos(|term) =
    ?term
  <+
    if <eq> (<get-constructor>, <get-constructor> term) then
      where(term' := <strip-annos> term);
      (?term' <+ strip-annos => term')
    end
  
  astr-uninitialize-node =
    topdown-consnil(try(
      \t {<is-astr-annotation>} -> t {}\
    <+
      \t {a*} -> t {b*}
       where
         b* := <filter(not(is-astr-annotation))> a*\
    ))
  
  astr-uninitialize-node-persist(|attribute-cache) =
    astr-uninitialize-node;
    set-keep-uninitialized(|attribute-cache, <id>)

strategies // Node initialization

  /**
   * Initialize a node, unless it was marked uninitialized by .uninit.
   */
  astr-initialize-node-prefer(|all-parents, attribute-cache) =
    get-keep-uninitialized(|attribute-cache, <id>)
  <+
    astr-initialize-node-ensure(|all-parents, attribute-cache)

  // TODO2: Don't re-init subtrees that are already registered to be inited
  //        (should use get-parent and needs NoParent)
  
  /**
   * Initialize a node if it was not yet initialized.
   */
  astr-initialize-node-ensure(|all-parents, attribute-cache) =
    astr-initialize-node-ensure(id|all-parents, attribute-cache)

  astr-initialize-node-ensure(warning|all-parents, attribute-cache) =
    if not(get-parent(|all-parents)) then
      where(warning);    
      astr-initialize-node(|all-parents, attribute-cache)
    end

  astr-initialize-node-warning(|attribute) =
    if not(AstrWarningsDisabled) then
      warn(|["Evaluating attribute '", attribute, "' on an uninitialized term"]);
      prim("SSL_stacktrace_get_all_frame_names");
      try(\["astr_initialize_node_warning_0_0" | tail] -> tail\);
      try(\["astr_initialize_node_ensure_1_1" | tail] -> tail\);
      reverse;
      map(<fprintnl> (stderr(), ["\t", <id>]))
    end
  
  astr-initialize-node(|all-parents, attribute-cache) =
    astr-initialize-node(|all-parents, attribute-cache, NoParent())
  
  astr-initialize-node(|all-parents, attribute-cache, parent) =
    // First add unique annos everywhere,
    // then assign parent rules for the newly formed nodes
    get-initialize-cache(|attribute-cache, <id>)
  <+
    ?node;
    astr-disable-sharing;
    set-initialize-cache(|attribute-cache, node, <id>);
    where(
      astr-add-parent-references(|all-parents, parent)
    )

strategies // Adding annotations

  // TODO: Consider using all-consnil to walk through lists

  astr-disable-sharing:
    t {a*} -> t' {b*}
    where
      t' := <all-consnil(astr-disable-sharing)> t;
      if [] := a* then
        b* := [<newname> "@"]
      else
        b* := [<newname> "@" | <astr-disable-sharing-of-annos> a*]
      end
  
  astr-disable-sharing-of-annos =
    filter(not(is-astr-annotation); astr-disable-sharing)

strategies // Hash table storage for init/uninit

  get-initialize-cache(|attribute-cache, node) =
    get-cached-attribute(|attribute-cache, node, "$inited")
 
  set-initialize-cache(|attribute-cache, node, value) =
    set-cached-attribute(|attribute-cache, node, "$inited", value)

  get-keep-uninitialized(|attribute-cache, node) =
    get-cached-attribute(|attribute-cache, node, "$uninited")
 
  set-keep-uninitialized(|attribute-cache, node) =
    set-cached-attribute(|attribute-cache, node, "$uninited", node)
    