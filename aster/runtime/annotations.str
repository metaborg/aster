module annotations

imports
  libstratego-lib
  parents
  lists

strategies // Util

  debug'(s) = where(strip-annos; debug(s))

  debug' = where(strip-annos; debug)
  
  // TODO2: Optimize - eq-ignore-annos is expensive
  
  eq-ignore-annos(|term) =
    ?term
  <+
    where( // cheapish base check, must at least pass this
      input-ctor := <get-constructor>{};
      term-ctor  := <get-constructor> term{};
      ?input-ctor
    );
    where(
      term' := <astr-remove-annos> term
    );
    where(
      ?term' <+ astr-remove-annos => term'
    )
  
  astr-remove-annos-persist(|attribute-cache) =
    astr-remove-annos;
    set-keep-uninitialized(|attribute-cache, <id>)

strategies // Node initialization

  // TODO: Use an "uninit" annotation instead of get-keep-uninitialized, its overhead, and possible bugs because of it...

  /**
   * Initialize a node, unless it was marked uninitialized by .uninit.
   */
  astr-initialize-node-prefer(|all-parents, attribute-cache) =
    get-keep-uninitialized(|attribute-cache, <id>)
  <+
    astr-initialize-node-ensure(|all-parents, attribute-cache)
  
  /**
   * Initialize a node if it was not yet initialized.
   */
  astr-initialize-node-ensure(|all-parents, attribute-cache) =
    astr-initialize-node-ensure(id|all-parents, attribute-cache)

  astr-initialize-node-ensure(warning|all-parents, attribute-cache) =
    if not(get-parent(|all-parents)) then
      where(warning);    
      astr-initialize-node(|all-parents, attribute-cache)
    end

  astr-initialize-node-warning(|attribute) =
    if not(AstrWarningsDisabled) then
      warn(|["Evaluating attribute '", attribute, "' on an uninitialized term"]);
      prim("SSL_stacktrace_get_all_frame_names");
      try(\["astr_initialize_node_warning_0_0" | tail] -> tail\);
      try(\["astr_initialize_node_ensure_1_1" | tail] -> tail\);
      reverse;
      map(<fprintnl> (stderr(), ["\t", <id>]))
    end
  
  astr-initialize-node-no-rewrite(|all-parents) =
    astr-initialize-node-no-rewrite(|all-parents, NoParent())
  
  astr-initialize-node-no-rewrite(|all-parents, parent) =
    // First add unique annos everywhere,
    // then assign parent rules for the newly formed nodes
    ?node;
    astr-add-annos;
    where(
      astr-add-parent-references(|all-parents, parent)
    )

strategies // Adding/removing node annotations

  astr-add-annos:
    t {a*} -> t' {b*}
    where
      t' := <all-consnil(astr-add-annos)> t;
      if [] := a* then
        b* := [<newname> "@"]
      else
        b* := [<newname> "@" | <filter(not(is-astr-annotation); astr-add-annos)> a*]
      end
  
  astr-remove-annos =
    topdown-consnil(try(
      \t {<is-astr-annotation>} -> t {}\
    <+
      ?_{}
    <+
      \t {a*} -> t {b*}
       where
         b* := <filter(not(is-astr-annotation))> a*\
    ))
  
  is-astr-annotation =
    // explode-string => ['@' | _] // too expensive me thinks
    is-string

strategies // Hash table storage for init/uninit

  /* UNDONE: Caching of node initialization
  
  // Caching of node initialization ensured:
  // - caching of attributes accross tree copies and rewrites of complete trees
  //   (but attribute caching and rewrite caching mostly takes care of that)
  // - cheap equality checks after every rewrite or circular evaluation
  //   (not really, unless you add an expensive remove-annos before caching)

  get-initialize-cache(|attribute-cache, parent, node) =
    where(NoParent() := parent);
    get-cached-attribute(|attribute-cache, node, "$inited")
 
  set-initialize-cache(|attribute-cache, parent, node, value) =
    not(NoParent() := parent) // no caching for you
  <+
    set-cached-attribute(|attribute-cache, node, "$inited", value)
  */

  get-keep-uninitialized(|attribute-cache, node) =
    get-cached-attribute(|attribute-cache, node, "$uninited")
 
  set-keep-uninitialized(|attribute-cache, node) =
    set-cached-attribute(|attribute-cache, node, "$uninited", node)
    