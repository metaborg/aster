/**
 * Collection attributes.
 *
 * @author Lennart Kats <lennart add lclnet.nl>
 */
module aster/attributes/collection

imports
  libstratego-lib
  aster/decorators/common
  aster/decorators/flow

decorators
  
  /**
   * Collects all nodes in the tree where the attribute can be applied,
   * including subnodes of the results.
   */
  decorator at-root collect-all(a) =
    collect-all(a, conc)
  
  /**
   * Maps over a list.
   *
   * id.map(s) is cached per list, while map(s) is cached per item.
   */
  decorator map(a) =
    map(a)
  
  // TODO2: Optimize - avoid dynamic rules in contributes-to decorator?
  
  /**
   * Create collections by adding the attribute value to each of the nodes
   * indicated by <targets>. When evaluated for one of the target nodes,
   * an attibute decorated with this decorator will return all
   * values contributed to it by other nodes.
   *
   * @param targets  The nodes to contribute this attribute value to.
   */
  decorator contributes-to(a, targets) =
    id.contributes-to(a, targets, id)
  
  /**
   * Create collections by adding the attribute value to each of the nodes
   * indicated by <targets>, using <target-to-key> to transform the
   * targets to a custom collection table key.
   *
   * @param targets        The nodes to contribute this attribute value to.
   * @param target-to-key  A tranformation to apply to each target.
   *                       For example, 'id.uninit' disregards the unique
   *                       identity of a node in the tree.
   */
  decorator node.contributes-to(a, targets, target-to-key) =
    if not(<CompletedSurvey> a.signature) then
      with(sig := a.signature);
      rules(CompletedSurvey: sig);
      
      id.root;
      topdown-consnil(where(try(
        { contribution:
          ?contribution;
          targets;
          (is-list <+ ![<id>]);
          map({ target:
            target-to-key => target;
            rules(
              Contributions :+ (sig, target) -> contribution
            )
          })
        }
      )))
    end;
    
    <bagof-Contributions> (a.signature, <target-to-key> node);
    filter(
      a
    <+
      if not(a.defined) then // sanity check
        fatal-err(|["Internal error in attribute '", a.attribute-name, "':",
                    "equation does not match targets definition"])
      end
    )
