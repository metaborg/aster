/**
 * Collection decorators.
 *
 * @author Lennart Kats <lennart add lclnet.nl>
 */
module aster/decorators/collection

imports
  libstratego-lib
  aster/decorators/common
  aster/decorators/flow

decorators

  TODO: 'all' decorator for collect-all
  
  /**
   * Collects all nodes in the tree where the attribute can be applied,
   * including subnodes of the results (using a conc union operator).
   */
  decorator at-root collect-all(a) =
    collect-all(a, conc)
  
  /**
   * Collects all nodes in the tree where the attribute can be applied,
   * including subnodes of the results, using a custom union operator.
   */
  decorator at-root collect-all(a, un) =
    collect-all(a, un)
  
  /**
   * Maps over a list.
   *
   * id.map(s) is cached per list, while map(s) is cached per item.
   */
  decorator map(a) =
    map(a)
  
  // TODO2: Optimize - avoid dynamic rules in contributes-to decorator?
  
  /**
   * Create collections by adding the attribute value to each of the nodes
   * indicated by <targets>. When evaluated for one of the target nodes,
   * an attibute decorated with this decorator will return all
   * values contributed to it by other nodes.
   *
   * @param targets  The nodes to contribute this attribute value to.
   */
  decorator contributes-to(a, targets) =
    id.contributes-to(a, targets, id)
  
  /**
   * Create collections by adding the attribute value to each of the nodes
   * indicated by <targets>, using <target-to-key> to transform the
   * targets to a custom collection table key.
   *
   * @param targets        The nodes to contribute this attribute value to.
   * @param target-to-key  A tranformation to apply to each target.
   *                       For example, 'id.uninit' disregards the unique
   *                       identity of a node in the tree.
   */
  decorator node.contributes-to(a, targets, target-to-key) =
    if not(<CompletedSurvey> a.signature) then
      <contributes-to-survey(targets, target-to-key |a.signature)> id.root
    end;
    
    <bagof-Contributions> (a.signature, <target-to-key> node);
    
    filter(
      if a.defined then
        a
      else
        fatal-err(|["Internal error in attribute '", a.attribute-name, "': ",
                    "equation does not match targets definition"])
      end
    )

strategies

  /**
   * Survey phase of the 'contributes-to' collection decorator.
   *
   * @internal
   */
  contributes-to-survey(targets, target-to-key |sig) =
    rules(CompletedSurvey: sig);
    
    topdown-consnil(where(try(
      { contribution:
        ?contribution;
        targets;
        (is-list <+ ![<id>]);
        map({ target:
          target-to-key => target;
          rules(
            Contributions :+ (sig, target) -> contribution
          )
        })
      }
    )))
