/**
 * Rule tracing.
 *
 * @author Lennart Kats <lennart add lclnet.nl>
 */
module back/rule-tracing

imports
  libstratego-lib
  back/util
  back/default-attributes
  back/attribute-references
  front/analyze

strategies

  trace-rule =
    trace-rule(|"")
  
  trace-default-rule =
    trace-rule(|" (copy rule)")
  
  trace-failed-rule =
    trace-rule(|" (failed)")
  
  trace-fixpoint-rule =
    trace-rule(|" (fixpoint)")
  
  trace-rule(|comment) =
    where(Attribute(real-name, _, _) := <RuleAttribute>);
    
    if <get-config> Trace(); not(<ignore-trace-def> real-name) then
      trace-rule(|comment, real-name)
    else
      !Strat |[ id ]|
    end
  
  trace-rule(|comment, real-name):
    def @ Attribute(name, sarity, tarity) ->
    Strat |[
        say(<conc-strings> (
             ~str:message
           , <s_path; (?"" <+ <conc-strings> (<id>, "."))>
           , <to-tiny-string>
           , t_comment*
        ))
      ]|
    with
      type       := <RuleAccessorType> def;
      arity'     := <arity-to-string> (sarity, tarity);
      circular   := <RuleAttribute; attribute-signature; AttributeCircular < !"circular " + !""> def;
      message    := <conc-strings> ("  [trace] ", circular, type, " ", real-name, arity', " @ ");
      s_path     := <trace-path>;
      
      if "" := comment then
        t_comment* := []
      else
        t_comment* := [Term |[ ~str:comment ]|]
      end
  
  trace-path =
    <assimilate-expr> <desugar-all> Strat |[ id.path-short ]|
  
  trace-rewrite =
    if <get-config> Trace() then
      with(
        x_node := <NodeVar>;
        s_path := <trace-path>
      );
      !Strat |[
        say(<conc-strings> (
          "  [rewrite] "
        , <s_path; (?"" <+ <conc-strings> (<id>, "."))> x_node
        , <to-tiny-string> x_node
        , " -> "
        , <to-tiny-string>
        ))
      ]|
    else
      !Strat |[ id ]|
    end
