module back/default-attributes

imports
  Stratego-Attributes
  stratego-rerag
  front/analyze

rules

  // FIXME: Remove attribute library to /runtime/ dir

  add-default-attributes:
    Module(name, decl*) -> Module(name, [decl*, attrs*])
    with
      attrs* := [<default-attributes>]

  default-attributes = !|[
    attributes
      def enable-warnings = rules(AstrWarningsDisabled :- _)
      
      def plain plain tree-access:
        id.prev-sibling  = get-prev-sibling(|id.parent)
        id.next-sibling  = get-next-sibling(|id.parent)
        id.first-sibling = get-first-child(|id.parent)
        id.last-sibling = get-last-child(|id.parent)
        id.first-child = get-first-child(|id)
        id.last-child = get-last-child(|id)
        id.prev-sibling(d) = get-prev-sibling(d|id.parent)
        id.next-sibling(d) = get-next-sibling(d|id.parent)
        id.child(d) = one(d; ?it); !it
      
      def plain root.is-root = id
      
      def plain all(d) =
        ?before;
        all(d);
        (?before <+ id.init)
      
      def plain some(d) =
        ?before;
        some(d);
        (?before <+ id.init)
      
      def down tree-access-ancestors:
        id.root = try(id.root)
        id.ancestor(p) = p <+ id.parent.ancestor(p)
        // id.ancestors(p,path) := <p <+ path; id.ancestors(p, path)>
      
      def path =
        id.path-list;
        reverse;
        map(get-constructor; as-string);
        separate-by(|".");
        concat-strings
      
      def path-and-node =
        where(node := <to-tiny-string>);
        id.path;
        (?"" < !node + <conc-strings> (<id>, ".", node));
        string-as-chars(
          truncate-path-lists;
          if <gt> (<string-length>, 60) then
            reverse;
            take(|60);
            reverse;
            !['.', '.', '.' | <id>]
          end
        )
      
      // TODO: Could the language indicate that these operate on uninitialized terms?
      // TODO: Could the language indicate that these don't require caching?
      //       (maybe a modifier 'plain' for both these, as not caching is still expensive if you have to init the term)
      def set:
        id.union = union(id.eq) <+ foldr(![], union(id.eq))
        id.diff = diff(id.eq)   <+ foldr(![], diff(id.eq))
        id.isect = isect(id.eq) <+ foldr(<Hd> set, isect(id.eq)) <+ ![]
        id.make-set = foldr(![], id.union, ![<id>])
      
      def (key,list).lookup = lookup(id.eq)
      def list.lookup(|keyb) = <lookup(id.eq)> (keyb, list)
      
    // Decorators
      
      /**
       * Applies the attribute semantic rule at the root of the tree.
       */
      decorator down at-root(d) =
        if id.is-root then
          d
        else
          id.parent.at-root(d)
        end
      
      // TODO: Should collect-all et al accept only soft failure?
      //       (and how to express that nicely?)
      
      /**
       * Collects all nodes in the tree where the attribute can be applied,
       * including subnodes of the results.
       */
      decorator at-root collect-all(d) =
        collect-all(d, conc)
      
      /**
       * Maps over a list.
       *
       * def map(id.attr) is cached per list, while map(id.s) is cached per item.
       */
      decorator map(d) = map(d)
      
      /* TODO: Should `soft-try` be factored out again?
               What does that mean for decorator definitions,
               they are then basically the same as their strategy equivalents?
      
      decorator stry(d) =
        id.eval(d, id)
      */
            
      decorator rewrite-td(d) =
        if d.defined then
          d
        end;
        id.all(id.rewrite-td(d))

      decorator rewrite-bu(d) =
        id.all(id.rewrite-bu(d));
        if d.defined then
          d
        end
      
      /**
       * Terminate with a fatal error if the decorated attribute results in a hard failure.
       */
      decorator fail-fatal(d):
        id -> result 
        where
          if d.defined then
            result := <d>
          <+
            log(|Critical(), ["Hard failure not expected in decorated attribute at", id.path], id.uninit);
            print-stacktrace;
            <exit> 1
          end
      
      decorator down(d) =
        if d.defined then
          d
        else
          id.parent;
          id.down(d)
        end
      
      decorator up(d) =
        if d.defined then
          d
        else
          id.child(d.defined; id.up(d))
        end
      
      /* TODO: Sane definition of `chained`
      //       should semantic rules be applied only once per node,
      //       not also on the second traversal in the chain?
      //       better way to express this?
      
      local `chained-syn`(d) = // main chained attribute uses d and propagates upwards
        id.eval(
          d
        ,
          id.last-child; `chained-syn`(d)
        <+
          id.prev-sibling; `chained-syn`(d)
        <+
          id.parent; `chained-syn-helper`(d)
        )
      
      local `chained-syn-helper`(d) = // helper chained attribute only propagates downwards
        id.prev-sibling; `chained-syn`(d)
      <+
        id.parent; `chained-syn-helper`(d)
      
      local `chained-inh`(d) = // main chained attribute only propagates upwards
        id.last-child; `chained-inh`(d)
      <+
        id.eval(
          d
        ,
          id.prev-sibling; `chained-inh`(d)
        <+
          id.parent; `chained-inh-helper`(d)
        )
      
      local `chained-inh-helper`(d) = // helper chained attribute uses d and propagates downwards
        id.eval(
          d
        ,
          id.prev-sibling; `chained-inh`(d)
        <+
          id.parent; `chained-inh-helper`(d)
        )
      */
      
      /**
       * Plain attributes do not have the default behavior of
       * caching and re-annotating a result term for re-attribution
       */
      decorator plain(d) = d // note that this is a special, built-in decorator
      
      decorator plain uncached(d) = d; id.ensure-init
        
      decorator down lookup-ordered(fetch, is-scope) =
        fetch
      <+
        id.prev-sibling(id.lookup-outside-scopes(is-scope, fetch))
      
      decorator down lookup-unordered(fetch, is-scope) =
        (id.is-root + is-scope);
        id.lookup-in-scope(is-scope, fetch)
      
      def plain lookup-in-scope(is-scope, fetch) =
        fetch
      <+
        id.child(id.lookup-outside-scopes(is-scope, fetch))
      
      def plain lookup-outside-scopes(is-scope, fetch) =
        fetch
      <+
        not(is-scope);
        id.child(id.lookup-outside-scopes(is-scope, fetch))
      
      decorator plain circular(d|initial-value) =
        let recompute(|old-value) =
          recompute-circular-def(id.plain(d)|d.signature, old-value)
        in
          if last-value := <get-last-value(|d.signature, id)> then
            if <?CIRCULAR_FINISHED(value) + ?CIRCULAR_BUSY(value)> last-value then
              !value
            else
              recompute(|last-value)
            end
          else
            where(
              old-value := <id.ensure-init <+ !EVAL_FAILED()> initial-value
            );
            circular-fixpoint'(recompute|old-value)
          end;
          not(EVAL_FAILED)
        end

      
      // TODO: local def covers(d|sort) = d
      
      // TODO: def default(d|value) = if d.defined then d else !value end
  ]|
  
  ignore-trace-def =
    // traces on path attributes cause looping
    "path" + "path-list" + "path-and-node" 
    // helper attributes where tracing is undesirable
  + "debug" + "enable-warnings" + "all"
  + "next-sibling" + "prev-sibling" + "first-sibling" + "last-sibling"
  + "root" + "first-child" + "last-child"
    // attributes dealing with uninitialized terms
  + "union" + "diff" + "isect"

rules // Native attribute definitions

  // Native attributes may work on non-annotated terms, or perform
  // special or optimized operations not directly supported by regular
  // attributes.
  
  // TODO2: Remove all assimilate-native-ref-inside-ag rules, and perform the optimization elswehere
  
  is-native-attribute =
    where(assimilate-native-attr)

  assimilate-native-ref:
    AttributeRef(t, attr) -> |[ !t; s ]|
    where
      s := <assimilate-native-attr> attr
  
  assimilate-native-ref-inside-ag(|s_parent, x_all-parents, x_current, x_attr-cache):
    AttributeRef(t, attr) -> |[ !t; s ]|
    where
      s := <assimilate-native-attr-inside-ag(|s_parent, x_all-parents, x_current, x_attr-cache)> attr
   
  assimilate-native-attr:
    Attribute("eq", [], [t]) -> |[ eq-ignore-annos(|t) ]|

  assimilate-native-attr:
    Attribute("eq", [], []) -> |[ where({ x: ?(<id>, x); eq-ignore-annos(|x) }) ]|
    where
      x := <new>

  assimilate-native-attr:
    Attribute("debug", [], []) -> |[ where(astr-remove-annos; debug) ]|

  assimilate-native-attr:
    Attribute("debug", [s], []) -> |[ where(astr-remove-annos; debug(s)) ]|
    
  assimilate-native-attr:
    Attribute("disable-warnings", [], []) -> |[ rules(AstrWarningsDisabled: _) ]|

  assimilate-native-attr:
    Attribute("parent", [], []) -> |[ get-parent(|<all-parents>); not(NoParent) ]|

  assimilate-native-attr-inside-ag(|s_parent, x_all-parents, x_current, x_attr-cache):
    Attribute("parent", [], []) -> |[ s_parent; not(NoParent) ]|
  
  assimilate-native-attr:
    Attribute("path-list", [], []) -> |[ get-ancestor-list(|<all-parents>) ]|

  assimilate-native-attr-inside-ag(|s_parent, x_all-parents, x_current, x_attr-cache):
    Attribute("path-list", [], []) -> |[ get-ancestor-list(|x_all-parents) ]|

  assimilate-native-attr:
    Attribute("uninit", [], []) -> |[ astr-remove-annos-persist(|<attr-cache>) ]|

  assimilate-native-attr-inside-ag(|s_parent, x_all-parents, x_current, x_attr-cache):
    Attribute("uninit", [], []) -> |[ astr-remove-annos-persist(|x_attr-cache) ]|
  
  assimilate-native-attr:
    Attribute("init", [], []) -> |[ astr-initialize-node(|<all-parents>, <attr-cache>) ]|
  
  assimilate-native-attr-inside-ag(|s_parent, x_all-parents, x_current, x_attr-cache):
    Attribute("init", [], []) -> |[ astr-initialize-node(|x_all-parents, x_attr-cache) ]|
  
  // TODO: id.eval() for regular attributes
  
  assimilate-native-attr:
    Attribute("eval", [s, s-default], []) -> |[ fatal-err(|"id.eval() not fully implemented yet") ]|
  
  assimilate-native-attr:
    Attribute("ensure-init", [], []) -> |[ astr-initialize-node-ensure(|<all-parents>, <attr-cache>) ]|
  
  assimilate-native-attr-inside-ag(|s_parent, x_all-parents, x_current, x_attr-cache):
    Attribute("ensure-init", [], []) -> |[ astr-initialize-node-ensure(|x_all-parents, x_attr-cache) ]|
    
rules // Native attributes on decorated evaluation functions

  is-native-attribute = is-decoration-native-attr
  
  is-decoration-native-attr =
    where(assimilate-decoration-native-attr(|"d")) // TODO: Proper native attr checks for decoration attrs

  assimilate-native-decoration-ref(|x_decorated):
    AttributeRef(Var(x_decorated), attr) -> <assimilate-decoration-native-attr(|x_decorated)> attr

  // TODO: Ideally, "d.defined" wouldn't evaluate d
  
  assimilate-decoration-native-attr(|x_decorated):
    Attribute("defined", [], []) ->
    |[ where(
         ?x_node
         < !x_cached <+ x_decorated => x_cached
         + x_decorated
       )
    ]|
    with
      x_cached := <DecoratedValueVar>;
      x_node   := <NodeVar>
  
  // FIXME: Decorator reflection
  
  assimilate-decoration-native-attr(|x_decorated):
    Attribute("name", [], []) -> |[ !"<decorated-attribute-name>" ]|
  
  assimilate-decoration-native-attr(|x_decorated):
    Attribute("signature", [], []) -> |[ !~str:sig ]|
    with
      sig := <conc-strings> ("<decorated-attribute-signature-", x_decorated, ">")
