module back/default-attributes

imports
  Stratego-Attributes
  stratego-rerag
  front/analyze

rules

  // TODO: Remove default attributes to /runtime/ dir

  add-default-attributes:
    Module(name, decl*) -> Module(name, [decl*, attrs*])
    with
      attrs* := [<default-attributes>]

  default-attributes = !|[
    attributes
      local enable-warnings = rules(AstrWarningsDisabled :- _)
      
      local tree-access:
        id.prev-sibling  = get-prev-sibling(|id.parent)
        id.next-sibling  = get-next-sibling(|id.parent)
        id.first-sibling = get-first-child(|id.parent)
        id.last-sibling = get-last-child(|id.parent)
        id.first-child = get-first-child(|id)
        id.last-child = get-last-child(|id)
      
      inh tree-access-ancestors:
        id.root = try(id.root)
        id.ancestor(p) = p <+ id.ancestor(p)
        id.ancestors(top,p) = top <+ p; id.ancestors(p, top)
      
      local path =
        id.path-list;
        reverse;
        map(get-constructor; as-string);
        separate-by(|".");
        concat-strings
      
      local path-and-node =
        where(node := <to-tiny-string>);
        id.path;
        (?"" < !node + <conc-strings> (<id>, ".", node));
        string-as-chars(
          truncate-path-lists;
          if <gt> (<string-length>, 60) then
            reverse;
            take(|60);
            reverse;
            !['.', '.', '.' | <id>]
          end
        )
      
      truncate-path-lists =
        // "[].[].[]." becomes "[].."
        ?['[', ']', '.' | <id>];
        repeat1(?['[', ']', '.' | <id>]);
        !['[', ']', '.', '.' | <truncate-path-lists>]
      <+
        [id | truncate-path-lists]
      <+
        []
      
      // TODO: Could the language indicate that these operate on uninitialized terms?
      // TODO: Could the language indicate that these don't require caching?
      //       (maybe a modifier 'plain' for both these, as not caching is still expensive if you have to init the term)
      local set:
        id.union = union(id.eq) <+ foldr(![], union(id.eq))
        id.diff = diff(id.eq)   <+ foldr(![], diff(id.eq))
        id.isect = isect(id.eq) <+ foldr(![], isect(id.eq))
        id.make-set = foldr(![], id.union, ![<id>])
      
      // Decorators
      
      /**
       * Applies the attribute semantic rule at the root of the tree.
       */
      inh `at-root`(d) =
        `at-root`(d) <+ d
      
      /**
       * Collects all nodes in the tree where the attribute can be applied,
       * including subnodes of the results.
       */
      `at-root` `collect-all`(d) =
        collect-all(d, concat)
      
      /**
       * Collects all nodes in the tree where the attribute can be applied.
       */
      `at-root` `collect`(d) =
        collect(d, concat)
      
      /**
       * Maps over a list.
       *
       * `map`(id.attr) is cached per list, while map(id.s) is cached per item.
       */
      local `map`(d) = map(d)

      local `bottomup-rewrite`(d) =
        id.eval(
          d
        , all(`bottomup-rewrite`(d))
        )
      
      local `inh`(d) =
        id.eval(
          d
        , id.parent; `inh`(d)
        )
      
      // TODO: Sane definition of `chained`
      //       should semantic rules be applied only once per node,
      //       not also on the second traversal in the chain?
      //       better way to express this?
      
      local `chained-syn`(d) = // main chained attribute uses d and propagates upwards
        id.eval(
          d
        ,
          id.last-child; `chained-syn`(d)
        <+
          id.prev-sibling; `chained-syn`(d)
        <+
          id.parent; `chained-syn-helper`(d)
        )
      
      local `chained-syn-helper`(d) = // helper chained attribute only propagates downwards
        id.prev-sibling; `chained-syn`(d)
      <+
        id.parent; `chained-syn-helper`(d)
      
      local `chained-inh`(d) = // main chained attribute only propagates upwards
          id.last-child; `chained-inh`(d)
        <+
          id.eval(
            d
          ,
            id.prev-sibling; `chained-inh`(d)
          <+
            id.parent; `chained-inh-helper`(d)
          )
      
      local `chained-inh-helper`(d) = // helper chained attribute uses d and propagates downwards
        id.eval(
          d
        ,
          id.prev-sibling; `chained-inh`(d)
        <+
          id.parent; `chained-inh-helper`(d)
        )
  ]|
  
  ignore-trace-def =
    // traces on path attributes cause looping
    "path" + "path-list" + "path-and-node" 
    // helper attributes where tracing is undesirable
  + "debug" + "enable-warnings"
  + "next-sibling" + "prev-sibling" + "first-sibling" + "last-sibling"
  + "root" + "first-child" + "last-child"
    // attributes dealing with uninitialized terms
  + "union" + "diff" + "isect"

rules // Native attribute definitions

  // Native attributes may work on non-annotated terms, or perform
  // special or optimized operations not directly supported by regular
  // attributes.
  
  // TODO2: Remove all assimilate-native-ref-inside-ag rules, and perform the optimization elswehere
  
  is-native-attribute =
    where(assimilate-native-attr)

  assimilate-native-ref:
    AttributeRef(t, attr) -> |[ !t; s ]|
    where
      s := <assimilate-native-attr> attr
  
  assimilate-native-ref-inside-ag(|s_parent, x_all-parents, x_current, x_attr-cache):
    AttributeRef(t, attr) ->
    |[ !t; s ]|
    where
      s := <assimilate-native-attr-inside-ag(|s_parent, x_all-parents, x_current, x_attr-cache)> attr
   
  assimilate-native-attr:
    Attribute("eq", [], [t]) -> |[ eq-ignore-annos(|t) ]|

  assimilate-native-attr:
    Attribute("eq", [], []) -> |[ { x: ?(<id>, x); eq-ignore-annos(|x) } ]|
    where
      x := <new>

  assimilate-native-attr:
    Attribute("debug", [], []) -> |[ where(astr-remove-annos; debug) ]|

  assimilate-native-attr:
    Attribute("debug", [s], []) -> |[ where(astr-remove-annos; debug(s)) ]|
    
  assimilate-native-attr:
    Attribute("disable-warnings", [], []) -> |[ rules(AstrWarningsDisabled: _) ]|

  assimilate-native-attr:
    Attribute("parent", [], []) -> Strat |[ get-parent(|<all-parents>); not(NoParent) ]|

  assimilate-native-attr-inside-ag(|s_parent, x_all-parents, x_current, x_attr-cache):
    Attribute("parent", [], []) -> Strat |[ s_parent; not(NoParent) ]|
  
  assimilate-native-attr:
    Attribute("path-list", [], []) -> |[ get-ancestor-list(|<all-parents>) ]|

  assimilate-native-attr-inside-ag(|s_parent, x_all-parents, x_current, x_attr-cache):
    Attribute("path-list", [], []) -> |[ get-ancestor-list(|x_all-parents) ]|

  assimilate-native-attr:
    Attribute("uninit", [], []) -> Strat |[ astr-remove-annos-persist(|<attr-cache>) ]|

  assimilate-native-attr-inside-ag(|s_parent, x_all-parents, x_current, x_attr-cache):
    Attribute("uninit", [], []) -> Strat |[ astr-remove-annos-persist(|x_attr-cache) ]|
  
  assimilate-native-attr:
    Attribute("init", [], []) -> Strat |[ astr-initialize-node(|<all-parents>, <attr-cache>) ]|
  
  assimilate-native-attr-inside-ag(|s_parent, x_all-parents, x_current, x_attr-cache):
    Attribute("init", [], []) -> Strat |[ astr-initialize-node(|x_all-parents, x_attr-cache) ]|
  
  // TODO: id.eval() for regular attributes
  
  assimilate-native-attr:
    Attribute("eval", [s, s-default], []) -> |[ fatal-err(|"id.eval() not fully implemented yet") ]|
  
  assimilate-native-attr:
    Attribute("ensure-init", [], []) -> Strat |[ astr-initialize-node-ensure(|<all-parents>, <attr-cache>) ]|
  
  assimilate-native-attr-inside-ag(|s_parent, x_all-parents, x_current, x_attr-cache):
    Attribute("ensure-init", [], []) -> Strat |[ astr-initialize-node-ensure(|x_all-parents, x_attr-cache) ]|
