module back/default-attributes

imports
  Stratego-Attributes
  stratego-rerag
  front/analyze

rules

  // TODO: Remove default attributes to /runtime/ dir

  add-default-attributes:
    Module(name, decl*) -> Module(name, [decl*, attrs*])
    with
      attrs* := [<default-attributes>]

  default-attributes = !|[
    attributes
      def enable-warnings = rules(AstrWarningsDisabled :- _)
      
      def plain tree-access:
        id.prev-sibling  = get-prev-sibling(|id.parent)
        id.next-sibling  = get-next-sibling(|id.parent)
        id.first-sibling = get-first-child(|id.parent)
        id.last-sibling = get-last-child(|id.parent)
        id.first-child = get-first-child(|id)
        id.last-child = get-last-child(|id)
        id.prev-sibling(d) = get-prev-sibling(d|id.parent)
        id.next-sibling(d) = get-next-sibling(d|id.parent)
        id.child(d) = one(d; ?it); !it
      
      def plain all(d) =
        ?before;
        all(d);
        (?before <+ id.init)
      
      def plain some(d) =
        ?before;
        some(d);
        (?before <+ id.init)
      
      def down tree-access-ancestors:
        id.root = try(id.root)
        id.ancestor(p) = p <+ id.ancestor(p)
        // id.ancestors(p,path) := <p <+ path; id.ancestors(p, path)>
      
      def path =
        id.path-list;
        reverse;
        map(get-constructor; as-string);
        separate-by(|".");
        concat-strings
      
      def path-and-node =
        where(node := <to-tiny-string>);
        id.path;
        (?"" < !node + <conc-strings> (<id>, ".", node));
        string-as-chars(
          truncate-path-lists;
          if <gt> (<string-length>, 60) then
            reverse;
            take(|60);
            reverse;
            !['.', '.', '.' | <id>]
          end
        )
      
      // TODO: Could the language indicate that these operate on uninitialized terms?
      // TODO: Could the language indicate that these don't require caching?
      //       (maybe a modifier 'plain' for both these, as not caching is still expensive if you have to init the term)
      def set:
        id.union = union(id.eq) <+ foldr(![], union(id.eq))
        id.diff = diff(id.eq)   <+ foldr(![], diff(id.eq))
        id.isect = isect(id.eq) <+ foldr(![], isect(id.eq))
        id.make-set = foldr(![], id.union, ![<id>])
      
      // Decorators
      
      /* TODO: eval with hard-fail argument (once the syntax allows it)
      
      local `eval`(s, soft-fail, hard-fail) =
        id.eval(s, soft-fail <+ ?soft-fail) < not(!soft-fail)
                                            + hard-fail
      */
      
      /**
       * Applies the attribute semantic rule at the root of the tree.
       */
      decorator down at-root(d) =
        id.at-root(d) <+ d
      
      // TODO: Should collect-all et al accept only soft failure?
      //       (and how to express that nicely?)
      
      /**
       * Collects all nodes in the tree where the attribute can be applied,
       * including subnodes of the results.
       */
      def at-root collect-all(d) =
        collect-all(d, conc)
      
      /**
       * Maps over a list.
       *
       * `map`(id.attr) is cached per list, while map(id.s) is cached per item.
       */
      decorator map(d) = map(d)
      
      /* TODO: Should `soft-try` be factored out again?
               What does that mean for decorator definitions,
               they are then basically the same as their strategy equivalents?
      
      decorator stry(d) =
        id.eval(d, id)
      */
            
      decorator rewrite-td(d) =
        id.eval(d, id);
        id.all(id.rewrite-td(d))

      decorator rewrite-bu(d) =
        id.all(id.rewrite-bu(d));
        id.eval(d, id)
      
      /**
       * Terminate with a fatal error if the decorated attribute results in a hard failure.
       */
      decorator hard-fail-fatal(d):
        id -> result 
        where
          id.eval(d, ?soft-fail) => result
          < not(!soft-fail)
          + log(|Critical(), ["Hard failure not expected in decorated attribute at", id.path], id.uninit);
            print-stacktrace;
            <exit> 1
      
      decorator down(d) =
        if d.defined then
          d
        else
          id.parent;
          id.down(d)
        end
      
      decorator up(d) =
        if d.defined then
          d
        else
          id.child(d.defined; id.up(d))
        end
      
      /* TODO: Sane definition of `chained`
      //       should semantic rules be applied only once per node,
      //       not also on the second traversal in the chain?
      //       better way to express this?
      
      local `chained-syn`(d) = // main chained attribute uses d and propagates upwards
        id.eval(
          d
        ,
          id.last-child; `chained-syn`(d)
        <+
          id.prev-sibling; `chained-syn`(d)
        <+
          id.parent; `chained-syn-helper`(d)
        )
      
      local `chained-syn-helper`(d) = // helper chained attribute only propagates downwards
        id.prev-sibling; `chained-syn`(d)
      <+
        id.parent; `chained-syn-helper`(d)
      
      local `chained-inh`(d) = // main chained attribute only propagates upwards
        id.last-child; `chained-inh`(d)
      <+
        id.eval(
          d
        ,
          id.prev-sibling; `chained-inh`(d)
        <+
          id.parent; `chained-inh-helper`(d)
        )
      
      local `chained-inh-helper`(d) = // helper chained attribute uses d and propagates downwards
        id.eval(
          d
        ,
          id.prev-sibling; `chained-inh`(d)
        <+
          id.parent; `chained-inh-helper`(d)
        )
      */
  ]|
  
  ignore-trace-def =
    // traces on path attributes cause looping
    "path" + "path-list" + "path-and-node" 
    // helper attributes where tracing is undesirable
  + "debug" + "enable-warnings" + "all"
  + "next-sibling" + "prev-sibling" + "first-sibling" + "last-sibling"
  + "root" + "first-child" + "last-child"
    // attributes dealing with uninitialized terms
  + "union" + "diff" + "isect"

rules // Native attribute definitions

  // Native attributes may work on non-annotated terms, or perform
  // special or optimized operations not directly supported by regular
  // attributes.
  
  // TODO2: Remove all assimilate-native-ref-inside-ag rules, and perform the optimization elswehere
  
  is-native-attribute =
    where(assimilate-native-attr)

  assimilate-native-ref:
    AttributeRef(t, attr) -> |[ !t; s ]|
    where
      s := <assimilate-native-attr> attr
  
  assimilate-native-ref-inside-ag(|s_parent, x_all-parents, x_current, x_attr-cache):
    AttributeRef(t, attr) -> |[ !t; s ]|
    where
      s := <assimilate-native-attr-inside-ag(|s_parent, x_all-parents, x_current, x_attr-cache)> attr
   
  assimilate-native-attr:
    Attribute("eq", [], [t]) -> |[ eq-ignore-annos(|t) ]|

  assimilate-native-attr:
    Attribute("eq", [], []) -> |[ where({ x: ?(<id>, x); eq-ignore-annos(|x) }) ]|
    where
      x := <new>

  assimilate-native-attr:
    Attribute("debug", [], []) -> |[ where(astr-remove-annos; debug) ]|

  assimilate-native-attr:
    Attribute("debug", [s], []) -> |[ where(astr-remove-annos; debug(s)) ]|
    
  assimilate-native-attr:
    Attribute("disable-warnings", [], []) -> |[ rules(AstrWarningsDisabled: _) ]|

  assimilate-native-attr:
    Attribute("parent", [], []) -> |[ get-parent(|<all-parents>); not(NoParent) ]|

  assimilate-native-attr-inside-ag(|s_parent, x_all-parents, x_current, x_attr-cache):
    Attribute("parent", [], []) -> |[ s_parent; not(NoParent) ]|
  
  assimilate-native-attr:
    Attribute("path-list", [], []) -> |[ get-ancestor-list(|<all-parents>) ]|

  assimilate-native-attr-inside-ag(|s_parent, x_all-parents, x_current, x_attr-cache):
    Attribute("path-list", [], []) -> |[ get-ancestor-list(|x_all-parents) ]|

  assimilate-native-attr:
    Attribute("uninit", [], []) -> |[ astr-remove-annos-persist(|<attr-cache>) ]|

  assimilate-native-attr-inside-ag(|s_parent, x_all-parents, x_current, x_attr-cache):
    Attribute("uninit", [], []) -> |[ astr-remove-annos-persist(|x_attr-cache) ]|
  
  assimilate-native-attr:
    Attribute("init", [], []) -> |[ astr-initialize-node(|<all-parents>, <attr-cache>) ]|
  
  assimilate-native-attr-inside-ag(|s_parent, x_all-parents, x_current, x_attr-cache):
    Attribute("init", [], []) -> |[ astr-initialize-node(|x_all-parents, x_attr-cache) ]|
  
  // TODO: id.eval() for regular attributes
  
  assimilate-native-attr:
    Attribute("eval", [s, s-default], []) -> |[ fatal-err(|"id.eval() not fully implemented yet") ]|
  
  assimilate-native-attr:
    Attribute("ensure-init", [], []) -> |[ astr-initialize-node-ensure(|<all-parents>, <attr-cache>) ]|
  
  assimilate-native-attr-inside-ag(|s_parent, x_all-parents, x_current, x_attr-cache):
    Attribute("ensure-init", [], []) -> |[ astr-initialize-node-ensure(|x_all-parents, x_attr-cache) ]|
    
