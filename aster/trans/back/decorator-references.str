/**
 * Aster decorator reference assimilation.
 *
 * @author Lennart Kats <lennart add lclnet.nl>
 */
module decorator-references

imports
  libstratego-lib
  front/analyze
  back/attribute-references
  back/decorator-wrapping
  back/decorator-definitions
  
rules // Decorator references
      
  assimilate-decorator-ref:
    Strategy |[ t.x_name(s_decorated, s*|t*) ]| ->
    |[ { ~x_scoped*:
         let x_cached =
           // Can't assume caching here, and is likely already performed inside
           s_eval
         in
           !t; x_cached
         end
       }
    ]|
    with
      ?AttributeRef(_, attr)
    where
      <is-decorator> attr
    with
      {| AttributeArgValues:
        if (s_decorated-renamed, s_decorated') := <assimilate-decorator-call-arg> s_decorated then
          // Body is an attribute call; arguments are stored in local variables
          t_decorated := <to-attribute-signature-term> s_decorated-renamed;
          x_scoped*   := <AttributeArgValues>
        else
          s_decorated' := s_decorated;
          t_decorated  := <to-attribute-signature-term <+ !Term |[ Anonymous() ]|>;
          x_scoped*    := []
        end;
  
        x_cached := <CachedVar>; // (not actually cached)
        s_eval   := <make-decorated(|t_decorated)> (Decorator(x_name, s*, t*), s_decorated')
      |}
  
  // Recursive decorator reference
  assimilate-decorator-self-ref(|x_decorated, x_decorator, s_arg*, t_arg*):
    Strategy |[ t.x_decorator(x_decorated(|), s_arg* |t_arg*) ]| ->
    Strategy |[ <x_cached> t ]|
    with
      x_cached := <CachedVar>

strategies // Wrapping helpers: directly invoked decorators (e.g., id.down(id.x))

  /**
   * Replace attribute arguments with variables,
   * and assimilate the attribute call without an EVAL_FAILED check.
   * The argument values are stored in the AttributeArgValue rule.
   *
   * Returns the attribute with renamed arguments,
   * and a desugared version forming a regular strategy.
   *
   * Defines AttributeArgValues.
   */
  assimilate-decorator-call-arg:
    Strategy |[ t.x_name(s*|t*) ]| -> (s_ref-sugar, s_ref)
    with
      x_var* := <map(<newname> "arg")> t*;
      t'*    := <zip(attribute-arg-to-var)> (t*, x_var*);
      
      rules(AttributeArgValues := x_var*);
      
      s_ref-sugar := Strategy |[ t.x_name(s*|t'*) ]|;
      s_ref       := <assimilate-expr; try(remove-eval-failed)>
 
   assimilate-decorator-call-arg:
     |[ x_decorated(|) ]| -> (<id>, s)
     where
       CurrentDecoratorArgument => x_decorated
     with
       s := <remove-eval-failed> <assimilate-decorated-svar(|x_decorated)>;
       rules(
         AttributeArgValues := []
       )
  
  remove-eval-failed: |[ s; not(EVAL_FAILED) ]| -> s
  remove-eval-failed: |[ s; s_tail ]|           -> |[ s; ~<remove-eval-failed> s_tail ]|
 
  /** 
   * Converts a directly decorated attribute call argument into a variable.
   */
  attribute-arg-to-var:
    (t_arg, x_var) -> Var(x_var)
    with
      rules(AttributeArgValue: x_var -> t_arg)

  /**
   * Provides the value of a directly decorated attribute call.
   *
   * @see attribute-to-attribute-signature-term
   */
  attribute-var-to-arg:
    Var(x_var) -> |[ <x_var := t_arg> ]|
    where
      t_arg := <AttributeArgValue> x_var
