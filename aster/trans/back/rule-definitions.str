module back/rule-definitions

imports
  Stratego-Attributes
  stratego-rerag
  back/default-attributes
  back/util
  back/rule-merging
  back/rule-defaults
  back/rule-naming
  back/attribute-references

overlays
  /**
   * The number of fixed arguments present in each attribute evaluation strategy.
   */
  AG_STANDARD_ARGS = 4

strategies

  // TODO2: runtime check for annotated terms used for/by dynamic rules

 assimilate-def:
   AttributeDef(
     type
   , t_pattern
   , AttributeDefStrategy(child, attr @ Attribute(name, as*, a*), _, s)
   ) ->
   <make-merged-def(|attr, t_pattern, child, type-name)>
   Def |[
     x_eval(as* |x_parent, x_all-parents, x_attr-cache, x_rewrite-mode, a'*) =
       ?x_node;
       where(s_init-args);
       s_pattern;
       s'
   ]|
   with
     x_parent           := <ParentVar>;
     x_node             := <NodeVar>;
     x_all-parents      := <AllParentsVar>;
     x_attr-cache       := <AttrCacheVar>;
     x_rewrite-mode     := <RewriteModeVar>;
     type-name          := <attribute-type-name(|type)> attr;
     sig                := <attribute-signature> attr;
     x_eval             := <attribute-accessor-name(|type-name)> attr;
     (a'*, s_init-args) := <extract-arg-patterns> a*;
     
     s_parent         := |[ ?x_node; !x_parent; not(UnknownParent)
                            <+ get-parent(|x_all-parents) ]|;
     s_parent-desired := |[ ?x_node < !x_parent + !UnknownParent() ]|;
     
     if NoChild() := child then
       Root()    := t_pattern;
       s_pattern := <root-pattern(|x_parent, x_all-parents)>
     <+
       s_pattern := |[ ?t_pattern ]|
     else // Inherited attribute
       Child(child') := child;
       s_pattern     := <ancestor-check(|child', x_parent, x_all-parents)> t_pattern
     end;
     
     !s;
     topdown(try(
       assimilate-expr-inside-ag(|sig, s_parent, s_parent-desired, x_node, x_all-parents, x_attr-cache)
     ));
     add-eval-failed => s'
   
  assimilate-def:
    AttributeDecl(_, _, _, _) -> []
   
  root-pattern(|x_parent, x_all-parents) =
    !|[ where(
         ?root;
         UnknownParent() := x_parent
           < get-parent(|x_all-parents); NoParent
           + <NoParent> x_parent
        )
    ]|

rules // Argument patterns
  
  extract-arg-patterns =
    unzip(extract-arg-pattern);
    (id, fold-seq)
  
  extract-arg-pattern:
    t -> (DefaultVarDec(x_name), |[ t' := x_name ]|)
    with
      t'     := <alltd(match-var-ignore-annos)> t; // don't care about annos
      x_name := <newname> "arg"
  
  match-var-ignore-annos:
    Var(x) ->
    Term |[
      <(id < id + ?x); // x may be bound or not; turn off compiler complaints
       (?x <+ eq-ignore-annos(|x))>
    ]| 

rules // Semantic rule definition helpers

  add-eval-failed:
    Seq(WhereClause(s1), s2) -> |[ where(s1); (s2 <+ !EVAL_FAILED()) ]|
  
  add-eval-failed:
    s -> |[ s <+ !EVAL_FAILED() ]|
    where
      not(?Seq(WhereClause(c), _))
  
  /**
   * Match based on an ancestor (e.g., for inh Foo(Bar(x)).x).
   */
  ancestor-check(|x_child, x_parent, x_all-parents):
    t_pattern ->
    |[ ?x_child;
       where(
         (!x_parent; not(UnknownParent) <+ s_traverse-up);
         s_traverse-up';
         ?t_pattern
       )
    ]|
    with
      depth          := <dec> <term-depth(|Var(x_child))> t_pattern;
      s_traverse-up  := |[ get-parent(|x_all-parents); not(NoParent) ]|;
      s_traverse-up' := <copy; fold-seq> (depth, s_traverse-up)
    
    // TODO2: Optimize - ancestor-check should use intermediate patterns
      