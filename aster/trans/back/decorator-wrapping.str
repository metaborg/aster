/**
 * Aster decorator wrapping.
 * Wraps decorator calls around attribute definitions.
 *
 * @author Lennart Kats <lennart add lclnet.nl>
 */
module decorator-wrapping

imports
  libstratego-lib
  front/analyze
  back/attribute-references
  back/decorator-definitions

rules // Adding decoration logic to decorated rules

  add-decorated-rule-logic(|def):
    |[ x_eval(sa*|a*) =
         s_rewrite => x_node;
         s_body
    ]| ->
    |[ x_eval(sa*|a*) =
         s_rewrite => x_node;
         where(s_init-args);
         s_body'
    ]|
    with
        <get-attribute-decorators> def => ds
    where
      // UNDONE: having a 'plain' decorator made _everything_ uncached
      //         filter(not(PLAIN_DECORATOR => is-caching-disabled)) => ds;
      
      !ds => [_ | _]
    with
      (s*, t*)    := <params-to-vars> (sa*, a*);
      s_init-args := <decorator-init-args; fold-seq> a*;
      
      let is-caching-disabled =
        ?once;                            // only affect the inner attribute evaluation;
        <not(has-foreign-operations)> def // disable caching if not required by the equations
      in
        s_body' :=
          <try(add-ensure-init(|def));
           fold-decorated-with-caching(is-caching-disabled|ds, def, s*, t*)> s_body
      end

  /**
   * Handling of attribute term/pattern arguments used by decorators.
   */  
  decorator-init-args:
    a* -> set-param*
    with
      // Ignore standard attribute and decorator parameters
      <drop(|DEFAULT_ARG_COUNT())> a*;
      filter(not(param-to-var; extract-arg-pattern-ignore));
      
      // TODO2: Optimize - only add arg initialization if used
      map({
        Var(x_param) := <param-to-var>;
        t_user-param := <MatchingUserParam> x_param;
        !|[ t_user-param := x_param ]|
      }) => set-param*

  /**
   * Adds strategy calls to the end of an attribute definition
   * to ensure the resulting term is initialized.
   */
  add-ensure-init(|def):
    s ->
    |[ s; (EVAL_FAILED <+ aster-initialize-attribute-value(|x_all-parents, x_global-cache)) ]|
    where
      not(<has-plain-decorator <+ has-foreign-operations> def)
    with
      x_all-parents  := <AllParentsVar>;
      x_global-cache := <GlobalCacheVar>
    
  fold-decorated-with-caching(is-caching-disabled|decorators, def, s*, t*) =
    ?s_body;
    !decorators;
    foldr(
      !s_body
    , let
        set-caching-disabled = try(?is-caching-disabled)
        is-caching-disabled' = where(!is-caching-disabled) + is-caching-disabled
      in
        make-decorated-ignore-markers;
        set-caching-disabled
      <+
        make-decorated-with-caching(set-caching-disabled, is-caching-disabled' |def, s*, t*);
        assimilate-all-inside-decorator;
        rename-cached-var
      end
    )
  
  /**
   * Avoids directly generating code for marker decorator (e.g., 'plain').
   */
  make-decorated-ignore-markers:
    (marker, s_decorated) -> s_decorated
    where
      <is-marker-decorator> marker
   
  /**
   * Creates a decorated attribute body, taking caching into consideration.
   *
   * @param set-caching-disabled  If invoked, caching is disabled from this decorator on
   * @param is-caching-disabled   Checks if caching is disabled through success/failure
   */
  make-decorated-with-caching(set-caching-disabled, is-caching-disabled|def, s*, t*):
    (decorator, s_decorated) ->
    |[ let x_cached =
         s_cache-read // note: this could be EVAL_FAILED
       <+
         { x_cached-node: ?x_cached-node;
           s_ref;
           s_cache-write
         }
       in
         x_cached;
         not(EVAL_FAILED)
       end
    ]|
    with
      x_cached      := <CachedVar>;
      x_cached-node := <newname> "cached-node";
      t_decorated   := <decorated-signature(|s*, t*)> def;

      if is-caching-disabled <+ <has-plain-decorator> decorator then
        set-caching-disabled;
        s_cache-read  := Fail();
        s_cache-write := Id();
        s_decorated'  := s_decorated // don't disable inner caching
      else
        {| NodeVar:
          rules(NodeVar := x_cached-node);
          s_cache-read  := <add-cache-read(|s*, t*)> def;
          s_cache-write := <add-cache-write(|s*, t*)> def
        |};
        s_decorated'  := <avoid-caching-undecorated-values> s_decorated
      end;
      
      s_ref := <make-decorated(|t_decorated)> (decorator, s_decorated')

  /**
   * Removes global cache-writes from inner decorator applications.
   * This avoids a potential problem with attributes that have 
   * stacked decorators, each using a shared caching table.
   * (Alternatively, they could use separate caching tables.)
   */
  avoid-caching-undecorated-values =
    alltd(
      \|[ set-cached-attribute(|~_, ~_, ~_, ~_) ]| -> Id()\
    )
  
  /**
   * Determines the signature argument of a decorator call,
   * for use with the id.signature attribute.
   */
  decorated-signature(|s*, t*):
    Attribute(x_decorated, _, _) -> t_decorated
    with
      if <IsDecoratorAccessorName> x_decorated then
        t_decorated := Var(<SignatureVar>)
      else
        t_decorated := <to-attribute-signature-term> Attribute(x_decorated, s*, <drop(|DEFAULT_ARG_COUNT())> t*)
      end
  
  /**
   * Creates a decorated attribute body.
   *
   * @see make-decorated-with-caching
   */
  make-decorated(|t_decorated-signature):
    (Decorator(x_decorator, s*, t*), s_decorated) ->
    <desugar-all>
    Strat |[
      id.x_decorator'(x_cached, s_decorated, s* |t_decorated-signature, t*)
    ]|
    with
      x_cached     := <CachedVar>;
      x_decorator' := <DecoratorAccessorName> x_decorator

strategies // Reflective data helpers
 
  to-attribute-signature-term =
    try(?Scope(_, <id>));
    try(?AttributeRef(_, <id>));
    attribute-to-attribute-signature-term
  <+
    DecoratedAttributeSignature
  <+
    Var(id)
  
  /** @internal */
  attribute-to-attribute-signature-term:
    Attribute(x_name, sa*, a*) ->
    Term |[ Attribute(~str:x_name, [~*sargs], [~*targs]) ]|
    with
      // Formal parameters
      targs := <params-to-vars> a*;
      sargs := <params-to-string-terms> sa*
    <+
      // Arguments
      targs := <map(attribute-var-to-arg <+ Var(id))> a*;
      sargs := <map(!Term |[ Anonymous() ]|)> sa*

strategies // General helpers
  
  /**
   * Provide new cache vars for each decorator application.
   *
   * For stacked decorations, a new cache variable name must be used
   * for each decorator application.
   */
  rename-cached-var =
    with(
      old-name := <CachedVar>;
      new-name := <newname>
    );
    alltd((old-name -> new-name))

  assimilate-all-inside-decorator =
    topdown(try(assimilate-expr-inside-decorator))
  
  assimilate-expr-inside-decorator =
    with(
      x_parent := <ParentVar>;
      x_node   := <NodeVar>;
      s_parent := |[ ?x_node < !x_parent + !UnknownParent() ]|
    );
    assimilate-expr-inside-ag(|s_parent, s_parent)
