/**
 * Default rule definitions for attributes.
 *
 * Default rules or "copy rules" can be used to
 * implicitly propagate a value through the tree.
 *
 * Default rules are invoked if:
 *  a) No semantic rule matches for a pattern
 *     (i.e., soft failure occurs)
 *
 *  b) An attribute is called recursively, e.g.:
 *     inh root = id.root <+ id
 *
 * @author Lennart Kats <lennart add lclnet.nl>
 */
module back/rule-defaults

imports
  libstratego-lib
  back/util
  back/rule-tracing
  back/rule-merging
  back/assimilate

strategies

  add-default-rules:
    Module(x, decl*) -> Module(x, [decl*, defaults*])
    with
      bagof-AllRules;
      map({
        ?def;
        default-rule;
        try(add-empty-chained-rules(|def))
      });
      flatten-list;
      defaults* := [Rules(<id>)]
  
  default-rule:
    def @ Attribute(_, sarity, tarity) ->
    <make-merged-def-default>
    |[
      x_eval(as*|a*) =
        s_trace;
        s_rule'
    ]|
    with
      type     := <get-attribute-type> def;
      (as*,a*) := <RuleParams> def;
      (s*,t*)  := <params-to-vars> (as*,a*);
      x_eval   := <RuleAccessorName> def;
      s_call   := |[ x_eval(s*|t*) ]|;
      s_rule   := <default-rule(|s_call, def)> type;
      s_rule'  := <try(make-decorator-default-rule(|def))> s_rule;

      if Local() := type then
        s_trace := Id()
      else
        s_trace := <trace-default-rule> def
      end

rules
   
  /**
   * Add default, empty semantic rules for chained attributes.
   * (In case only synthesized or only inherited definitions were provided.)
   */
  add-empty-chained-rules(|def):
    default-rule ->
    Def* |[
      ~default-rule
      x_eval-inh(as*|a*) = fail
      x_eval-syn(as*|a*) = fail
    ]|
    where
      <get-attribute-type> def => Chained()
    with
      x_eval-inh := <attribute-accessor-name(|"inh")> def;
      x_eval-syn := <attribute-accessor-name(|"syn")> def;
      (as*,a*)   := <RuleParams> def;
      (s*,t*)    := <params-to-vars> (as*,a*)

rules // copy rules

  // Local has a default rule '!EVAL_FAILED' for caching of fails and proper tracing
  default-rule(|s_call, def):
    Local() -> |[ !EVAL_FAILED() ]|

  default-rule(|s_call, def):
    Decorated(ds) ->
    |[ let x_cached =
         s_cache-read;
         s_call // No cache writing w/ altered strat. argument
       in
         s_decorated;
         not(EVAL_FAILED)
       end
    ]|
    with
      x_cached      := <CachedVar>;
      (s*, a*)      := <params-to-vars> <RuleParams> def;
      s_cache-read  := <add-cache-read(|s*, a*)> def;
      s_call'       := <add-one-soft-failure> s_call;
      s_decorated   := <foldr(!s_call', make-decorated)> ds

  add-one-soft-failure:
    s_eval ->
    |[ (id < id + ?x_failed-once); // ensure it's bound
       if !x_failed-once then
         s_eval
       else
         ?x_failed-once;
         fail
       end
    ]|
    with
      x_failed-once := <newname> "failed-once"
 
  default-rule(|s_call, def):
    Inh() ->  
    |[ // id.parent.attr
       (!x_parent; not(UnknownParent) <+ get-parent(|x_all-parents));
       not(NoParent);
       x_eval(s* |<get-parent(|x_all-parents) <+ !UnknownParent()>, x_all-parents, t*)
    ]|
    with
      !s_call => |[ x_eval(s* |x_parent, x_all-parents, t*) ]|
  
  // TODO: Or should the syn copy rule consider all following children after "soft failure"?
  
  default-rule(|s_call, def):
    Syn() ->
    |[
       ?x_node;
       get-first-child(|x_node);
       x_eval(s* |x_node, t*)
    ]|
    with
      x_node  := <NodeVar>;
      x_value := <newname> "value";
      !s_call => |[ x_eval(s* |x_parent, t*) ]|
  
  default-rule(|s_call, def):
    Chained() ->
    |[ get-prev-sibling(|x_parent)
       < x_eval-syn(s* |x_parent, t*)    // id.syn_attr
       + !x_parent;
         x_eval(s* |UnknownParent(), t*) // id.parent.inh_attr
    ]|
    where
      "inh" := <RuleAccessorType> def // context is an inh rule def
    with
      !s_call     => |[ x_eval(s* |x_parent, t*) ]|;
      x_eval-syn := <attribute-accessor-name(|"syn")> def
      
  default-rule(|s_call, def):
    Chained() ->
    |[ ?x_node;
       get-last-child(|<id>)
       < x_eval(s* |x_node, t*)       // id.last-child.syn_attr
       + x_eval-inh(s* |x_parent, t*) // id.inh_attr
    ]|
    where
      "syn" := <RuleAccessorType> def // context is a syn rule def
    with
      !s_call    => |[ x_eval(s* |x_parent, t*) ]|;
      x_node     := <NodeVar>;
      x_eval-inh := <attribute-accessor-name(|"inh")> def
      
  default-rule-name =
    attribute-signature => sig;
    ( DefaultRuleName
    <+
      ?Attribute(x_eval, _, _);
      name := <conc-strings; newname> ("eval-", x_eval, "-default");
      rules(
        DefaultRuleName: sig -> name
      )
    )
  
  default-rule-call =
    default-rule-call-from-attr
  <+
    default-rule-call-by-sig
  
  default-rule-call-from-attr =
    ?Attribute(_, as*, a*);
    x_eval-default := <default-rule-name> <attribute-signature>;
    (s*, t*)       := <params-to-vars> (as*, a*);
    default-t*     := <default-args>;
    
    default-rule-call(|x_eval-default, s*, [default-t*, t*])
  
  default-rule-call-by-sig =
    attribute-signature => sig;
    x_eval-default := <default-rule-name> sig;
    (s*, t*)       := <params-to-vars> <RuleParams> sig;
    
    default-rule-call(|x_eval-default, s*, t*)
    
  default-rule-call(|x_eval-default, s*, t*) =
    !|[
      x_eval-default(s*|t*)
    ]|
