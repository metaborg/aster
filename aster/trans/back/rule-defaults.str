/**
 * Default rule definitions for attributes.
 *
 * Default rules or "copy rules" can be used to
 * implicitly propagate a value through the tree.
 *
 * Default rules are invoked if:
 *  a) No semantic rule matches for a pattern
 *     (i.e., soft failure occurs)
 *
 *  b) An attribute is called "recursively," e.g.:
 *     inh root = id.root <+ id
 *
 * @author Lennart Kats <lennart add lclnet.nl>
 */
module back/rule-defaults

imports
  libstratego-lib
  back/util
  back/rule-tracing
  back/rule-merging
  back/assimilate

strategies

  add-default-rules:
    Module(x, decl*) -> Module(x, [decl*, defaults*])
    with
      bagof-AllRules;
      map(
        default-rule
      );
      flatten-list;
      defaults* := [Rules(<id>)]
  
  default-rule:
    def @ Attribute(_, sarity, tarity) ->
    <make-merged-def-default>
    |[
      x_eval(sa*|a*) =
        s_trace;
        s_rule'
    ]|
    with
      decorators := <get-attribute-decorators> def;
      (sa*,a*)   := <RuleParams> def;
      (s*,t*)    := <params-to-vars> (sa*,a*);
      x_eval     := <RuleAccessorName> def;
      s_call     := |[ x_eval(s*|t*) ]|;
      s_rule     := <default-rule(|s_call, def)> decorators;
      s_rule'    := <try(make-decorator-default-rule(|def))> s_rule;

      if [] := decorators then
        s_trace  := Id()
      else
        s_trace  := <trace-default-rule> def
      end

rules
   
  /*
   * UNDONE: Added default, empty semantic rules for chained attributes.
   *         (this was applied after default-rule before)
   * (In case only synthesized or only inherited definitions were provided.)
   *
  add-empty-chained-rules(|def):
    default-rule ->
    Def* |[
      ~default-rule
      x_eval-inh(sa*|a*) = fail
      x_eval-syn(sa*|a*) = fail
    ]|
    where
      <get-attribute-decorators> def => Chained()
    with
      x_eval-inh := <attribute-accessor-name(|"inh")> def;
      x_eval-syn := <attribute-accessor-name(|"syn")> def;
      (sa*,a*)   := <RuleParams> def;
      (s*,t*)    := <params-to-vars> (sa*,a*)
  */

rules // copy rules

  default-rule(|s_call, def) =
    default-rule-native(|s_call, def)
  <+
    default-rule-decorators(|s_call, def)

  // Local has a default rule '!EVAL_FAILED' for caching of fails and proper tracing
  default-rule-native(|s_call, def):
    [] -> |[ !EVAL_FAILED() ]|

  // TODO: I'm not sure if these default-rule semantics are desirable anymore
  // FIXME: ^ this probably breaks certain cases of circular decorators

  // For decorators, the default rule is only ever invoked
  // for recursive calls (e.g., inh foo = <inc> id.foo).
  default-rule-decorators(|s_call, def):
    decorators ->
    |[ s_decorated; not(EVAL_FAILED) ]|
    with
      (s*,  t*)   := <params-to-vars> <RuleParams> def;
      s_call'     := <add-one-soft-failure> s_call;
      // TODO: Is caching after add-one-soft-failure harmful?
      s_decorated := <foldr(!s_call', make-decorated-with-caching(|def, s*, t*))> decorators

  add-one-soft-failure:
    s_eval ->
    |[ (id < id + ?x_failed-once); // ensure it's bound
       if !x_failed-once then
         s_eval
       else
         ?x_failed-once;
         fail
       end
    ]|
    with
      x_failed-once := <newname> "failed-once"
 
  default-rule-native(|s_call, def):
    ["inh"] ->  
    |[ // id.parent.attr
       (!x_parent; not(UnknownParent) <+ get-parent(|x_all-parents));
       not(NoParent);
       x_eval(s* |<get-parent(|x_all-parents) <+ !UnknownParent()>, x_all-parents, t*)
    ]|
    with
      !s_call => |[ x_eval(s* |x_parent, x_all-parents, t*) ]|
  
  // TODO: Or should the syn copy rule consider all following children after "soft failure"?
  
  default-rule(|s_call, def):
    ["syn"] ->
    |[
       ?x_node;
       one(x_eval(s* |x_node, t*) => x_value);
       !x_value
    ]|
    with
      x_node  := <NodeVar>;
      x_value := <newname> "value";
      !s_call => |[ x_eval(s* |x_parent, t*) ]|
  
  /* UNDONE: Different default rules for chained inh and syn definitions
  default-rule(|s_call, def):
    ["chained"] ->
    |[ get-prev-sibling(|x_parent)
       < x_eval-syn(s* |x_parent, t*)    // id.syn_attr
       + !x_parent;
         x_eval(s* |UnknownParent(), t*) // id.parent.inh_attr
    ]|
    where
      "inh" := <RuleAccessorType> def // context is an inh rule def
    with
      !s_call     => |[ x_eval(s* |x_parent, t*) ]|;
      x_eval-syn := <attribute-accessor-name(|"syn")> def
      
  default-rule(|s_call, def):
    ["chained"] ->
    |[ ?x_node;
       get-last-child(|<id>)
       < x_eval(s* |x_node, t*)       // id.last-child.syn_attr
       + x_eval-inh(s* |x_parent, t*) // id.inh_attr
    ]|
    where
      "syn" := <RuleAccessorType> def // context is a syn rule def
    with
      !s_call    => |[ x_eval(s* |x_parent, t*) ]|;
      x_node     := <NodeVar>;
      x_eval-inh := <attribute-accessor-name(|"inh")> def
  */
      
  default-rule-name =
    attribute-signature => sig;
    ( DefaultRuleName
    <+
      ?Attribute(x_eval, _, _);
      name := <conc-strings; newname> ("eval-", x_eval, "-default");
      rules(
        DefaultRuleName: sig -> name
      )
    )
  
  default-rule-call =
    default-rule-call-from-attr
  <+
    default-rule-call-by-sig
  
  default-rule-call-from-attr =
    ?Attribute(_, sa*, a*);
    x_eval-default := <default-rule-name> <attribute-signature>;
    (s*, t*)       := <params-to-vars> (sa*, a*);
    default-t*     := <default-args>;
    
    default-rule-call(|x_eval-default, s*, [default-t*, t*])
  
  default-rule-call-by-sig =
    attribute-signature => sig;
    x_eval-default := <default-rule-name> sig;
    (s*, t*)       := <params-to-vars> <RuleParams> sig;
    
    default-rule-call(|x_eval-default, s*, t*)
    
  default-rule-call(|x_eval-default, s*, t*) =
    !|[
      x_eval-default(s*|t*)
    ]|
