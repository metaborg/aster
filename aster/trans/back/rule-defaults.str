/**
 * Default rule definitions for attributes.
 *
 * Default rules or "copy rules" can be used to
 * implicitly propagate a value through the tree.
 *
 * Default rules are invoked if:
 *  a) No semantic rule matches for a pattern
 *     (i.e., soft failure occurs)
 *
 *  b) An attribute is called recursively, e.g.:
 *     inh root = id.root <+ id
 *
 * @author Lennart Kats <lennart add lclnet.nl>
 */
module back/rule-defaults

imports
  libstratego-lib
  back/util
  back/rule-tracing
  back/rule-merging
  back/assimilate

strategies

  add-default-rules:
    Module(x, decl*) -> Module(x, [decl*, defaults*])
    with
      bagof-AllRules;
      map({
        ?def;
        default-rule;
        try(add-empty-chained-rules(|def))
      });
      flatten-list;
      defaults* := [Rules(<id>)]
  
  default-rule:
    def @ Attribute(_, sarity, tarity) ->
    <make-merged-def-default>
    |[
      x_eval(sa*|a*) =
        s_trace;
        s_rule'
    ]|
    with
      type     := <get-attribute-type> def;
      (sa*,a*) := <RuleParams> def;
      (s*,t*)  := <params-to-vars> (sa*,a*);
      x_eval   := <RuleAccessorName> def;
      s_call   := |[ x_eval(s*|t*) ]|;
      s_rule   := <default-rule(|s_call, def)> type;
      s_rule'  := <try(make-decorator-default-rule(|def))> s_rule;

      if Local() := type then
        s_trace := Id()
      else
        s_trace := <trace-default-rule> def
      end

rules

  // TODO: Split up chained definitions to a new inh and syn part
  //       each with its own signature for the two copy rules.
  //       How would the copy rules fall back to their
  //       counterpart on soft failure?
   
  /**
   * Add default, empty semantic rules for chained attributes.
   * (In case only synthesized or only inherited definitions were provided.)
   */
  add-empty-chained-rules(|def):
    default-rule ->
    Def* |[
      ~default-rule
      x_eval-inh(sa*|a*) = fail
      x_eval-syn(sa*|a*) = fail
    ]|
    where
      <get-attribute-type> def => Chained()
    with
      x_eval-inh := <attribute-accessor-name(|"inh")> def;
      x_eval-syn := <attribute-accessor-name(|"syn")> def;
      (sa*,a*)   := <RuleParams> def;
      (s*,t*)    := <params-to-vars> (sa*,a*)

rules // copy rules

  // Local has a default rule '!EVAL_FAILED' for caching of fails and proper tracing
  default-rule(|s_call, def):
    Local() -> |[ !EVAL_FAILED() ]|

  // For decorators, the default rule is only ever invoked
  // for recursive calls (e.g., inh foo = <inc> id.foo).
  default-rule(|s_call, def):
    Decorated(ds) ->
    |[ s_decorated; not(EVAL_FAILED) ]|
    with
      (s*,  t*)   := <params-to-vars> <RuleParams> def;
      s_call'     := <add-one-soft-failure> s_call;
      // TODO: Is caching after add-one-soft-failure harmful?
      s_decorated := <foldr(!s_call', make-decorated-with-caching(|def, s*, t*))> ds
  
  /*
  default-rule(|s_call, def):
    Decorated(ds) -> s_call'
    with
      !s_call;
      debug'(!0);
      !s_call   => |[ x_eval(s_cached, s* |t*) ]|;
      tiny-debug(!1);
      s_cached' := <add-one-soft-failure> s_cached;
      tiny-debug(!2);
      s_call'   := |[ x_eval(s_cached', s* |t*) ]|
      ;tiny-debug(!3)
  */
  
  /*
  default-rule(|s_call, def):
    Decorated(ds) ->
    |[ s_decorated; not(EVAL_FAILED) ]|
    with
      (s*,  t*)   := <params-to-vars> <RuleParams> def;
      s_call'     := <add-one-soft-failure> s_call;
      // TODO: Is caching after add-one-soft-failure harmful?
      s_decorated := <foldr(!s_call', make-decorated-with-caching(|def, s*, t*))> ds
   */

  add-one-soft-failure:
    s_eval ->
    |[ (id < id + ?x_failed-once); // ensure it's bound
       if !x_failed-once then
         s_eval
       else
         ?x_failed-once;
         fail
       end
    ]|
    with
      x_failed-once := <newname> "failed-once"
 
  default-rule(|s_call, def):
    Inh() ->  
    |[ // id.parent.attr
       (!x_parent; not(UnknownParent) <+ get-parent(|x_all-parents));
       not(NoParent);
       x_eval(s* |<get-parent(|x_all-parents) <+ !UnknownParent()>, x_all-parents, t*)
    ]|
    with
      !s_call => |[ x_eval(s* |x_parent, x_all-parents, t*) ]|
  
  // TODO: Or should the syn copy rule consider all following children after "soft failure"?
  
  default-rule(|s_call, def):
    Syn() ->
    |[
       ?x_node;
       get-first-child(|x_node);
       x_eval(s* |x_node, t*)
    ]|
    with
      x_node  := <NodeVar>;
      x_value := <newname> "value";
      !s_call => |[ x_eval(s* |x_parent, t*) ]|
  
  default-rule(|s_call, def):
    Chained() ->
    |[ get-prev-sibling(|x_parent)
       < x_eval-syn(s* |x_parent, t*)    // id.syn_attr
       + !x_parent;
         x_eval(s* |UnknownParent(), t*) // id.parent.inh_attr
    ]|
    where
      "inh" := <RuleAccessorType> def // context is an inh rule def
    with
      !s_call     => |[ x_eval(s* |x_parent, t*) ]|;
      x_eval-syn := <attribute-accessor-name(|"syn")> def
      
  default-rule(|s_call, def):
    Chained() ->
    |[ ?x_node;
       get-last-child(|<id>)
       < x_eval(s* |x_node, t*)       // id.last-child.syn_attr
       + x_eval-inh(s* |x_parent, t*) // id.inh_attr
    ]|
    where
      "syn" := <RuleAccessorType> def // context is a syn rule def
    with
      !s_call    => |[ x_eval(s* |x_parent, t*) ]|;
      x_node     := <NodeVar>;
      x_eval-inh := <attribute-accessor-name(|"inh")> def
      
  default-rule-name =
    attribute-signature => sig;
    ( DefaultRuleName
    <+
      ?Attribute(x_eval, _, _);
      name := <conc-strings; newname> ("eval-", x_eval, "-default");
      rules(
        DefaultRuleName: sig -> name
      )
    )
  
  default-rule-call =
    default-rule-call-from-attr
  <+
    default-rule-call-by-sig
  
  default-rule-call-from-attr =
    ?Attribute(_, sa*, a*);
    x_eval-default := <default-rule-name> <attribute-signature>;
    (s*, t*)       := <params-to-vars> (sa*, a*);
    default-t*     := <default-args>;
    
    default-rule-call(|x_eval-default, s*, [default-t*, t*])
  
  default-rule-call-by-sig =
    attribute-signature => sig;
    x_eval-default := <default-rule-name> sig;
    (s*, t*)       := <params-to-vars> <RuleParams> sig;
    
    default-rule-call(|x_eval-default, s*, t*)
    
  default-rule-call(|x_eval-default, s*, t*) =
    !|[
      x_eval-default(s*|t*)
    ]|
