module rule-circularity

imports
  libstratego-lib
  back/assimilate
  back/rule-tracing

strategies

  // TODO: Remove "native" circular attributes?

  add-circular-rule-logic(|def):
    |[ x_eval(sa*|a*) =
         s_rewrite => x_node;
         s_body
    ]| ->
    Def* |[
      /**
       * Read from cache, or enqueue into fixpoint with initial value
       */
      x_eval(|a*) =
        switch s_cache-read
          case ?CIRCULAR_FINISHED(x_cached) + ?CIRCULAR_BUSY(x_cached):
            <not(EVAL_FAILED)> x_cached
            // TODO: Don't fall back to outer choice for this failure
          
          case ?x_cached: // re-eval once per iteration
            x_eval-recompute(|x_cached, t*)
        end
      <+
        let eval(|x_old-value) =
          x_eval-recompute(|x_old-value, t*)
        in
          where(
            x_old-value := <s_ensure-init <+ !EVAL_FAILED()> t_initial
          );
          circular-fixpoint(eval |x_attr-cache, x_old-value);
          not(EVAL_FAILED)
        end
      
      /**
       * Uncached evaluator for use in fixpoint loop.
       *
       * @returns The initialized value produced by the semantic function, or EVAL_FAILED.
       */
      x_eval-recompute(|x_old-value, a*) =
        where({ x_node: // scope: x_node is set to the rewritten node value later
          ?x_node;
          <s_cache-write> CIRCULAR_BUSY(x_old-value)
        });
        
        s_rewrite => x_node;
        (s_body <+ !EVAL_FAILED());
        
        if eq-ignore-annos(|x_old-value) then
          // verbose-msg(!"  [circ.] No change @", <strip-annos> x_node, !"with", strip-annos);
          circular-add-participant(|x_attr-cache, x_node, t_name-args, x_old-value);
          <s_cache-write> x_old-value // remove CIRCULAR_BUSY
        else
          // verbose-msg(!"  [circ.] Changed @", <strip-annos> x_node, !"with", strip-annos, !"was", <strip-annos> x_old-value);
          astr-initialize-attribute-value(|x_all-parents, x_attr-cache);
          circular-set-has-changed(|x_attr-cache);
          s_cache-write
        end
    ]|
    where
      t_initial        := <get-attribute-circular> def
    with
      x_eval-recompute := <newname> <conc-strings> (x_eval, "-recompute");
      x_eval-enqueue   := <newname> <conc-strings> (x_eval, "-enqueue");
      x_attr-cache     := <AttrCacheVar>;
      x_all-parents    := <AllParentsVar>;
      x_node           := <NodeVar>;
      x_cached         := <newname> "cached";
      x_old-value      := <newname> "old-value";
      s_ensure-init    := Strat |[ astr-initialize-attribute-value(|x_all-parents, x_attr-cache) ]|;
      s_trace          := <trace-fixpoint-rule> def;
      ([], t*)         := <params-to-vars> ([], a*);
      t_name-args      := <make-cache-key(|t*)> def;
      s_cache-read     := <add-cache-read(|t*)> def;
      s_cache-write    := <add-cache-write(|t*)> def

      