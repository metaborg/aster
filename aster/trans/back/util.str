module back/util

imports
  libstratego-lib

strategies
    
  /**
   * Get the depth of the given node relative to the input term.
   * @type Term -> Int
   */
  term-depth(|child) =
    term-depth(|child, 0)
  
  term-depth(|child, initial) =
    try(roll-out-list-terms + roll-out-tuple-terms);
    ?Op(_, _);
    one(
      term-depth(|child, <inc> initial) => result
    );
    !result
  <+
    one(
      term-depth(|child, initial) => result
    );
    !result
  <+
    ?child;
    !initial
  
  roll-out-list-terms:
    List([t | t*]) -> Op("Cons", [t, List(t*)])
  
  roll-out-list-terms:
    ListTail(l1, l2) -> <roll-out-list-terms> List(<conc> (l1, [l2]))
  
  roll-out-list-terms:
    ListTail([], tail) -> <roll-out-list-terms> List(tail)

  roll-out-tuple-terms:
    Tuple(ts) -> Op("Tuple", ts)
  
  fold-seq =
    foldr(!Id(), \(x,y) -> Seq(x,y)\)
  
  fold-lchoice =
    foldr(!Fail(), \(x,y) -> LChoice(x,y)\)

  param-to-var:
    DefaultVarDec(x) -> Var(x)
  
  param-to-var:
    VarDec(x, _) -> CallNoArgs(Var(x))

  param-to-svar:
    DefaultVarDec(x) -> CallNoArgs(SVar(x))
  
  param-to-svar:
    VarDec(x, _) -> SVar(x)

  params-to-vars =
    (alltd(param-to-svar), alltd(param-to-var)) <+ map(param-to-var)
    
  arity-to-string =
    (0, 0); !""
  <+
    ?(sarity, tarity);
    <conc-strings> ("_", <as-string> sarity, "_", <as-string> tarity)
