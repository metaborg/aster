module rule-decorators

imports
  libstratego-lib
  front/analyze
  back/attribute-references
  
// TODO: Optimize: decorators should be inlined after the merging stage

// TODO: Decorator arguments?

rules // Decorator references
      
  assimilate-decorator-ref:
    AttributeRef(t, attr @ Attribute(x_name, [s_decorated | s*], t*)) ->
    |[ let x_cached =
         // Can't assume caching here, and is likely already performed inside
         s_eval
       in
         !t; x_cached
       end
    ]|
    where
      <is-decorator> attr; debug(!"decorator ref: ")
    with
      x_cached := <CachedVar>; // not actually cached
      s_eval   := <make-decorated> (Decorator(x_name, s*, t*), s_decorated)
  
  // Recursive decorator reference
  assimilate-decorator-self-ref(|attr, x_decorator, s_arg*, t_arg*):
    |[ t.x_decorator(s_arg* |t_arg*) ]| ->
    |[ !t;
       ?x_node < s_eval-default + x_cached
    ]|
    with
      x_node         := <NodeVar>;
      x_cached       := <CachedVar>;
      s_eval-default := <default-rule-call> attr
  
rules // Assimilation of decorator definitions

  // TODO: Caching of decorated attributes, in every `call`
  //       (by passing a rec argument that performs memoization)
  
  assimilate-decorator-def =
    AttributeDef(
      Type(Decorator(), id, id)
    , id
    , AttributeDefStrategy(
        id
      , record-decorator-type-wrap(
          Attribute(
            ?x_decorator
          , ?[a_decorated | as*];
            ![DefaultVarDec(<CachedVar>) | <id>]
          , ?a*
          ) => attr
        )
      , assimilate-decorator-body(|attr, x_decorator, as*, a*, a_decorated)
      )
    );
    assimilate-def
 
  assimilate-decorator-body(|attr, x_decorator, as*, a*, a_decorated) =
    with(
      Var(x_decorated) := <param-to-var> a_decorated;
      (s_arg*, t_arg*) := <params-to-vars> (as*, a*)
    );
    alltd(
      assimilate-decorator-self-ref(|attr, x_decorator, s_arg*, t_arg*)
    <+
      assimilate-decorated-svar(|attr, x_decorated)
    <+
      assimilate-native-decoration-ref(|x_decorated)
    )

  // TODO: Add eval to default-attributes, check.astr
  // TODO: Remove id.eval(s)
  
  /**
   * Assimilate a id.eval() decorator call, which
   * allows the specification of the default behavior
   * in case of soft failure.
   */
  assimilate-decorated-svar(|attr, x_decorated):
    Strat |[ t.eval(x_decorated(|), s_default|) ]| ->
    |[ !t;
       (x_decorated < not(EVAL_FAILED) + s_default)
    ]|

  assimilate-decorated-svar(|attr, x_decorated):
    |[ x_decorated(|) ]| -> |[ ~<id>; not(EVAL_FAILED) ]|
  
  /**
   * Record the type of a decorator rule.
   * (Must be done again after assimilation changes
   *  the signature.)
   */
  record-decorator-type-wrap(process-attribute) =
    ?attr-before;
    process-attribute;
    ?attr-after;
    
    with(
      sig  := <attribute-signature> attr-before;
      sig' := <attribute-signature> attr-after;
      debug(!"set type for");
      rules(
        AttributeDecorators: sig' -> <AttributeDecorators> sig
      )
    )
  
  /*
  assimilate-decorator-id:
    Decorator(x) -> x'
    with
      !x;
      string-as-chars(Tl);
      string-replace(|"`", "-decorator") => x';
      rules(
        IsDecoratorName: x'
      )
  */

rules // Finishing decorator copy rules

  make-decorator-default-rule(|def):
    |[ x_eval-default(sa*|a*) = s  ]| ->
    |[ x_eval-default(sa*|a*) = s' ]|
    where
      <is-decorator> def
    with
      <attribute-signature> def => Attribute(name, _, _);
      x_cached := <CachedVar>;
      s' := <alltd(
        (|[ x_eval(s*|t*) ]| -> Strat |[ x_cached ]|)
      )> s;
      rules(
        CallDecoratorDefaultRule: name -> |[ x_eval-default(s*|t*) ]|
      )

rules // Adding decoration logic to decorated rules

  add-decorated-rule-logic(|def):
    |[ x_eval(sa*|a*) =
         s_rewrite => x_node;
         s_body
    ]| ->
    |[ x_eval(sa*|a*) =
         s_rewrite => x_node;
         s_body'
    ]|
    where
      <get-attribute-decorators> def => [_ | _] => ds
    with
      (s*, t*) := <params-to-vars> (sa*, a*);
      s_body'  := <eliminate-copy-rule(|def);
                   add-ensure-init;
                   fold-decorated-with-caching(|ds, def, s*, t*)> s_body
  
  add-ensure-init:
    s ->
    |[ s; (EVAL_FAILED <+ astr-initialize-attribute-value(|x_all-parents, x_attr-cache)) ]|
    with
      x_all-parents := <AllParentsVar>;
      x_attr-cache  := <AttrCacheVar>
  
  /**
   * Eliminate copy rules merged in at an earlier stage.
   * (The default rule of decorated rules is only used for recursion.)
   */
  eliminate-copy-rule(|def) =
    where(
      default-rule := <default-rule-name> def
    );
    oncetd(
      (CallT(<oncetd(?default-rule)>, _, _) -> Fail())
    )
  
  fold-decorated-with-caching(|decorators, def, s*, t*) =
    ?s_body;
    !decorators;
    foldr(
      !s_body
    , make-decorated-with-caching(|def, s*, t*);
      inc-cache-var
    )
  
  make-decorated-with-caching(|def, s_arg*, t_arg*):
    (x_decorator, _) ->
    |[ let x_cached =
         s_cache-read // could be EVAL_FAILED
       <+
         s_ref; s_cache-write
         // TODO: Should the decorated copy rule be applied here??
       in
         x_cached;
         not(EVAL_FAILED)
       end
    ]|
    with
      s_ref         := <make-decorated>;
      x_cached      := <CachedVar>;
      
      if <is-plain-decorator> x_decorator then
        s_cache-read  := Fail();
        s_cache-write := Id()
      else
        s_cache-read  := <add-cache-read(|s_arg*, t_arg*)> def;
        s_cache-write := <add-cache-write(|s_arg*, t_arg*)> def
      end
  
  make-decorated:
    (Decorator(x_decorator, s*, t*), s_decorated) ->
    <assimilate-attr-ref-inside-decorator> <desugar-all> Strat |[
      id.x_decorator(x_cached, s_decorated', s* | t*)
    ]|
    with
      x_cached     := <CachedVar>;
      s_decorated' := s_decorated

strategies // Provide new cache vars for each decorator application

  // TODO2: Simplify this, seriously...
  
  inc-cache-var =
    inc-cache-var-prepare(|<CachedVar>, 0);
    alltd(IncCachedVar)
  
  // Rewrite cached0 to cached01, cached01 to cached02, etc.  
  inc-cache-var-prepare(|before, count) =
    where(
      cached := <CachedVar>
    );
    rules(
      IncCachedVar: before -> cached-count
      where
        cached-count := <conc-strings> (cached, <as-string> count);
        inc-cache-var-prepare(|cached-count, <inc> count)
    )

strategies // Helpers
  
  assimilate-attr-ref-inside-decorator =
    with(
      x_parent       := <ParentVar>;
      x_all-parents  := <AllParentsVar>;
      x_attr-cache   := <AttrCacheVar>;
      x_node         := <NodeVar>;
      s_parent       := |[ ?x_node < !x_parent + !UnknownParent() ]|
    );
    assimilate-attr-ref-inside-ag(|s_parent, s_parent, x_all-parents, x_node, x_attr-cache)
