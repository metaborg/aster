module rule-decorators

imports
  libstratego-lib
  front/analyze
  back/attribute-references
  
// TODO: Optimize: decorators should be inlined after the merging stage

overlays

  DECORATOR_ARG_COUNT = 1 // added system args for decorator strategies

rules // Decorator references
      
  assimilate-decorator-ref:
    AttributeRef(t, attr @ Attribute(x_name, [s_decorated | s*], t*)) ->
    |[ let x_cached =
         // Can't assume caching here, and is likely already performed inside
         s_eval
       in
         !t; x_cached
       end
    ]|
    where
      <is-decorator> attr
    with
      x_cached := <CachedVar>; // not actually cached
      s_eval   := <make-decorated> (Decorator(x_name, s*, t*), s_decorated)
  
  // Recursive decorator reference
  assimilate-decorator-self-ref(|attr, x_decorator, s_arg*, t_arg*):
    |[ t.x_decorator(s_arg* |t_arg*) ]| ->
    |[ !t;
       ?x_node < s_eval-default + x_cached
    ]|
    with
      x_node         := <NodeVar>;
      x_cached       := <CachedVar>;
      s_eval-default := <default-rule-call> attr
  
rules // Assimilation of decorator definitions

  // TODO: Caching of decorated attributes, in every `call`
  //       (by passing a rec argument that performs memoization)
  
  assimilate-decorator-def =
    AttributeDef(
      Type(Decorator(), id, id)
    , id
    , AttributeDefStrategy(
        id
      , Attribute(
          ?x_decorator; DecoratorInternalName
        , ?[a_decorated | as*];
          ![DefaultVarDec(<CachedVar>) | <id>]
        , ?a*
        ) => attr
      , assimilate-decorator-body(|attr, x_decorator, as*, a*, a_decorated)
      )
    );
    assimilate-def
 
  assimilate-decorator-body(|attr, x_decorator, as*, a*, a_decorated):
    s_body ->
    |[ (id < id + ?x_decorated-value);
       s_body'
    ]|
    with
      x_decorated-value := <DecoratedValueVar>;
      Var(x_decorated)  := <param-to-var> a_decorated;
      (s_arg*, t_arg*)  := <params-to-vars> (as*, a*);

      !s_body;
      
      alltd(
        assimilate-decorator-self-ref(|attr, x_decorator, s_arg*, t_arg*)
      <+
        assimilate-decorated-svar(|attr, x_decorated)
      <+
        assimilate-native-decoration-ref(|x_decorated)
      ) => s_body'

  // TODO: Only use decorated value var caching if the function is not "plain"
  // TODO2: Optimize - if this is done, it'd be safe to store the result in x_cached here
  assimilate-decorated-svar(|attr, x_decorated):
    |[ x_decorated(|) ]| ->
    |[ if ?x_node then
         !x_cached <+ x_decorated
       else
         x_decorated
       end;
       not(EVAL_FAILED)
    ]|
    with
      x_node   := <NodeVar>;
      x_cached := <DecoratedValueVar>

rules // Finishing decorator copy rules

  make-decorator-default-rule(|def):
    |[ x_eval-default(sa*|a*) = s  ]| ->
    |[ x_eval-default(sa*|a*) = s' ]|
    where
      <is-decorator> def
    with
      <attribute-signature> def => Attribute(name, _, _);
      x_cached := <CachedVar>;
      s' := <alltd(
        (|[ x_eval(s*|t*) ]| -> Strat |[ x_cached ]|)
      )> s;
      rules(
        CallDecoratorDefaultRule: name -> |[ x_eval-default(s*|t*) ]|
      )

rules // Adding decoration logic to decorated rules

  add-decorated-rule-logic(|def):
    |[ x_eval(sa*|a*) =
         s_rewrite => x_node;
         s_body
    ]| ->
    |[ x_eval(sa*|a*) =
         s_rewrite => x_node;
         s_body'
    ]|
    where
      <get-attribute-decorators> def => [_ | _] => ds
    with
      (s*, t*) := <params-to-vars> (sa*, a*);
      s_body'  := <eliminate-copy-rule(|def);
                   add-ensure-init;
                   fold-decorated-with-caching(|ds, def, s*, t*)> s_body
  
  add-ensure-init:
    s ->
    |[ s; (EVAL_FAILED <+ astr-initialize-attribute-value(|x_all-parents, x_attr-cache)) ]|
    with
      x_all-parents := <AllParentsVar>;
      x_attr-cache  := <AttrCacheVar>
  
  /**
   * Eliminate copy rules merged in at an earlier stage.
   * (The default rule of decorated rules is only used for recursion.)
   */
  eliminate-copy-rule(|def) =
    where(
      default-rule := <default-rule-name> def
    );
    oncetd(
      (CallT(<oncetd(?default-rule)>, _, _) -> Fail())
    )
  
  fold-decorated-with-caching(|decorators, def, s*, t*) =
    ?s_body;
    !decorators;
    foldr(
      !s_body
    , make-decorated-with-caching(|def, s*, t*);
      inc-cache-var
    )
  
  make-decorated-with-caching(|def, s_arg*, t_arg*):
    (x_decorator, _) ->
    |[ let x_cached =
         s_cache-read // could be EVAL_FAILED
       <+
         s_ref; s_cache-write
         // TODO: Should the decorated copy rule be applied here??
       in
         x_cached;
         not(EVAL_FAILED)
       end
    ]|
    with
      s_ref         := <make-decorated>;
      x_cached      := <CachedVar>;
      
      if <is-plain-decorator> x_decorator then
        s_cache-read  := Fail();
        s_cache-write := Id()
      else
        s_cache-read  := <add-cache-read(|s_arg*, t_arg*)> def;
        s_cache-write := <add-cache-write(|s_arg*, t_arg*)> def
      end
  
  make-decorated:
    (Decorator(x_decorator, s*, t*), s_decorated) ->
    <assimilate-attr-ref-inside-decorator> <desugar-all> Strat |[
      id.x_decorator'(x_cached, s_decorated', s* | t*)
    ]|
    with
      x_cached     := <CachedVar>;
      x_decorator' := <DecoratorInternalName> x_decorator;
      s_decorated' := s_decorated

strategies // Provide new cache vars for each decorator application

  // TODO2: Simplify this, seriously...
  
  inc-cache-var =
    inc-cache-var-prepare(|<CachedVar>, 0);
    alltd(IncCachedVar)
  
  // Rewrite cached0 to cached01, cached01 to cached02, etc.  
  inc-cache-var-prepare(|before, count) =
    where(
      cached := <CachedVar>
    );
    rules(
      IncCachedVar: before -> cached-count
      where
        cached-count := <conc-strings> (cached, <as-string> count);
        inc-cache-var-prepare(|cached-count, <inc> count)
    )

strategies // Helpers
  
  assimilate-attr-ref-inside-decorator =
    with(
      x_parent       := <ParentVar>;
      x_all-parents  := <AllParentsVar>;
      x_attr-cache   := <AttrCacheVar>;
      x_node         := <NodeVar>;
      s_parent       := |[ ?x_node < !x_parent + !UnknownParent() ]|
    );
    assimilate-attr-ref-inside-ag(|s_parent, s_parent, x_all-parents, x_node, x_attr-cache)
