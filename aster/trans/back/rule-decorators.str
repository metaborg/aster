module rule-decorators

imports
  libstratego-lib
  front/analyze
  back/attribute-references
  
// TODO: Optimize: decorators should be inlined after the merging stage

// TODO: Decorator arguments?

rules // Decorator references
      
  assimilate-decorator-ref:
    DecoratorRef(x_decorator, s_decorated) ->
    |[ let x_cached =
         // Can't assume caching here, and is likely already performed inside
         s_eval
       in
         x_cached
       end
    ]|
    with
      x_cached := <CachedVar>; // not actually cached
      s_eval   := <make-decorated> (x_decorator, s_decorated)
  
  // Recursive decorator reference
  assimilate-decorator-self-ref(|attr, decorator, x_decorated):
    DecoratorRef(decorator, |[ x_decorated(|) ]|) ->
    |[ ?x_node < s_eval-default + x_cached ]|
    with
      x_node         := <NodeVar>;
      x_cached       := <CachedVar>;
      s_eval-default := <default-rule-call> attr
  
rules // Assimilation of decorator definitions

  // TODO: Caching of decorated attributes, in every `call`
  //       (by passing a rec argument that performs memoization)
  
  assimilate-decorator-def =
    AttributeDef(
      id
    , id
    , AttributeDefStrategy(
        id
      , record-decorator-type-wrap(
          Attribute(
            ?Decorator(name);
            assimilate-decorator-id
          , ?[decorated | _];
            ![DefaultVarDec(<CachedVar>) | <id>]
          , id
          ) => attr
        )
      , id
      , assimilate-decorator-body(|attr, name, decorated)
      )
    );
    assimilate-def
 
  assimilate-decorator-body(|attr, decorator, decorated) =
    with(
      Var(x_decorated) := <param-to-var> decorated
    );
    alltd(
      assimilate-decorator-self-ref(|attr, decorator, x_decorated)
    <+
      assimilate-decorated-svar(|attr, x_decorated)
    )

  // TODO: Add try-eval to default-attributes, check.astr
  
  /**
   * Assimilate a id.eval() decorator call, which
   * allows the specification of the default behavior
   * in case of soft failure.
   */
  assimilate-decorated-svar(|attr, x_decorated):
    Strat |[ t.eval(x_decorated(|), s_default|) ]| ->
    |[ !t;
       (x_decorated <+ s_default);
       not(EVAL_FAILED)
    ]|

  assimilate-decorated-svar(|attr, x_decorated):
    |[ x_decorated(|) ]| -> |[ ~<id>; not(EVAL_FAILED) ]|
  
  /**
   * Record the type of a decorator rule.
   * (Must be done again after assimilation changes
   * the signature.)
   */
  record-decorator-type-wrap(process-attribute) =
    ?attr-before;
    process-attribute;
    ?attr-after;
    
    with(
      sig  := <attribute-signature> attr-before;
      sig' := <attribute-signature> attr-after;
      rules(
        AttributeType: sig' -> <AttributeType> sig
      )
    )
    
  assimilate-decorator-id:
    Decorator(x) -> x'
    with
      !x;
      string-as-chars(Tl);
      string-replace(|"`", "-decorator") => x';
      rules(
        IsDecoratorName: x'
      )

rules // Finishing decorator copy rules

  make-decorator-default-rule(|def):
    |[ x_eval-default(as*|a*) = s  ]| ->
    |[ x_eval-default(as*|a*) = s' ]|
    where
      <attribute-signature> def => Attribute(name, _, _);
      <IsDecoratorName> name
    with
      x_cached := <CachedVar>;
      s' := <alltd(
        (|[ x_eval(s*|t*) ]| -> Strat |[ x_cached ]|)
      )> s;
      rules(
        CallDecoratorDefaultRule: name -> |[ x_eval-default(s*|t*) ]|
      )

rules // Adding decorated rule logic

  add-decorated-rule-logic(|def):
    |[ x_eval(as*|a*) =
         s_rewrite => x_node;
         s_body
    ]| ->
    |[ x_eval(as*|a*) =
         s_rewrite => x_node;
         s_body'
    ]|
    where
      <get-attribute-type> def => Decorated(ds)
    with
      t*      := <params-to-vars> a*;
      s_body' := <foldr(!s_body, make-decorated-with-caching(|def, as*, t*))> ds
  
  make-decorated-with-caching(|def, s_arg*, t_arg*):
    (_, _) ->
    |[ let x_cached =
         s_cache-read // could be EVAL_FAILED
       <+
         s_ref; s_cache-write
       <+
         // TODO: The default, decorated copy rule should be applied here
         //       (for non-local decorated attributes)
         !EVAL_FAILED(); s_cache-write
       in
         x_cached;
         not(EVAL_FAILED)
       end
    ]|
    with
      s_ref         := <make-decorated>;
      x_cached      := <CachedVar>;
      s_cache-read  := <add-cache-read(|s_arg*, t_arg*)> def;
      s_cache-write := <add-cache-write(|s_arg*, t_arg*)> def
  
  make-decorated:
    (x_decorator, s_decorated) ->
    <assimilate-attr-ref-inside-decorator> <desugar-all> Strat |[
      id.x_decorator'(x_cached, s_decorated)
    ]|
    with
      x_cached     := <CachedVar>;
      x_decorator' := <assimilate-decorator-id> Decorator(x_decorator)

strategies // Helpers
  
  assimilate-attr-ref-inside-decorator =
    with(
      x_parent       := <ParentVar>;
      x_all-parents  := <AllParentsVar>;
      x_attr-cache   := <AttrCacheVar>;
      x_node         := <NodeVar>;
      s_parent       := |[ ?x_node < !x_parent + !UnknownParent() ]|
    );
    assimilate-attr-ref-inside-ag(|s_parent, s_parent, x_all-parents, x_node, x_attr-cache)
      
