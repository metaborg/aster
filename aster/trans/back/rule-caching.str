/**
 * Rule caching.
 *
 * @author Lennart Kats <lennart add lclnet.nl>
 */
module back/rule-caching

imports
  libstratego-lib
  back/util

rules

  add-cached-rule-logic(|def):
    |[ x_eval(as*|a*) = s ]| ->
    |[ x_eval(as*|a*) =
         s_cache-read
         < not(EVAL_FAILED)
         + s; // does ?x_node after rewrite
           if EVAL_FAILED then
             s_cache-write;
             fail
           else
             astr-initialize-attribute-value(|x_all-parents, x_attr-cache);
             s_cache-write
           end
    ]|
    where
      ([], a*) := <RuleParams> def     
    with
      ([], t*)      := <params-to-args> ([], a*);
      s_cache-read  := <add-cache-read(|t*)> def;
      s_cache-write := <add-cache-write(|t*)> def;
      x_all-parents := <AllParentsVar>;
      x_attr-cache  := <AttrCacheVar>
  
  add-uncached-rule-logic:
    |[ x_eval(as*|a*) = s ]| ->
    |[ x_eval(as*|a*) =
         s;
         not(EVAL_FAILED);
         astr-initialize-attribute-value(|x_all-parents, x_attr-cache)
    ]|
    with
      x_all-parents  := <AllParentsVar>;
      x_attr-cache   := <AttrCacheVar>

  add-cache-read(|sargs, targs) =
    if [] := sargs then
      add-cache-read(|targs)
    else
      !Fail()
    end

  add-cache-write(|sargs, targs) =
    if [] := sargs then
      add-cache-write(|targs)
    else
      !Id()
    end
  
  add-cache-read(|targs):
    def ->
    |[ get-cached-attribute(|x_attr-cache, <id>, t_key) ]|
    with
      x_all-parents := <AllParentsVar>;
      x_attr-cache  := <AttrCacheVar>;
      t_key         := <make-cache-key(|targs)> def

  add-cache-write(|targs):
    def ->
    |[ set-cached-attribute(|x_attr-cache, x_node, t_key, <id>) ]|
    with
      x_attr-cache  := <AttrCacheVar>;
      x_node        := <NodeVar>;
      t_key         := <make-cache-key(|targs)> def

  make-cache-key(|targs):
    Attribute(name, sarity, tarity) -> key
    with
      arity' := <arity-to-string> (sarity, tarity);
      name'  := <conc-strings> (name, arity');
      targs' := <drop(|DEFAULT_ARG_COUNT())> targs;
      
      !NoAnnoList(Str(name'));
      if not([] := targs') then
        !NoAnnoList(Tuple([<id>, targs']))
      end => key
