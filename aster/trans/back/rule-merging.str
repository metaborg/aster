module back/rule-merging

imports
  libstratego-lib
  back/util
  back/rule-tracing
  back/rule-caching
  back/rule-naming
  back/rule-circularity
  back/rule-decorators
  back/assimilate
  front/analyze

overlays
  DEFAULT_RULE_INDEX = -1
  ROOT_RULE_INDEX    = 100000
  NO_CHILD_INDEX     = 10000

strategies
  
  // TODO: Cheap circularity detection using counter argument?
  // TODO2: Optimize - inline rule defs in ordered rule defs?
  
  add-merged-rules:
    Module(x, decl*) -> Module(x, [decl*, ordered*])
    where
      bagof-AllRules;
      map(make-merged-rule);
      flatten-list;
      ordered* := [Rules(<id>)]
  
  add-merged-rule-logic(|def) =
    add-decorated-rule-logic(|def)
  <+
    add-circular-rule-logic(|def)
  <+
    add-cached-rule-logic(|def)
  <+
    add-uncached-rule-logic
  
  make-merged-rule:
    def @ Attribute(_, sarity, tarity) ->
    <add-merged-rule-logic(|def)> |[
      x_eval(sa*|a*) =
        s_rewrite => x_node; // (join point)
        s_trace;
        ( s // the parentheses ensure x_node is available to decorators 
        <+
          <s_trace-failed> x_node;
          fail // UNDONE: !EVAL_FAILED()
        )
    ]|
    with
      (sa*, a*)      := <RuleParams> def;
      (s*, t*)       := <params-to-vars> (sa*, a*);
      x_all-parents  := <AllParentsVar>;
      x_attr-cache   := <AttrCacheVar>;
      x_node         := <NodeVar>;
      x_eval         := <RuleAccessorName> def;
      defs           := <sort-ordered-defs> <make-set> <bagof-OrderedRuleDefs> def;
      s              := <fold-lchoice> <map(def-call(|s*, t*))> defs;
      s_trace        := <trace-rule> def;
      s_trace-failed := <trace-failed-rule> def;
      s_rewrite      := <add-rewrite(|x_all-parents, x_attr-cache)>

  // TODO2: Move this
  add-rewrite(|x_all-parents, x_attr-cache) =
    if UsesAnonymousRewriteRules then
      x_rewrite-mode := <RewriteModeVar>;
      !Strat |[
        if 1 := x_rewrite-mode then
          eval-anonymous-rewrites-cached(|x_all-parents, x_attr-cache)
        end
      ]|
    else
      !Strat |[ id ]|
    end

  def-call(|s*, t*):
    Attribute(x_eval, _, _) -> |[ x_eval(s*|t*) ]|

  sort-ordered-defs =
    map(!(<OrderedRuleIndex>, <id>));
    qsort({
      ?((index1, _), (index2, _));
      <gt> (index1, index2)
    });
    map(Snd)

strategies

  make-merged-def(|pattern, child, accessor-type) =
    with(
      record-def(|accessor-type)
    );
    if Root() := pattern then
      make-merged-def-root
    else
      make-merged-def(|pattern, <pattern-order-index(|child)> pattern)
    end
  
  make-merged-def(|pattern, index):
    |[ x_eval(sa*|a*) = s ]| -> |[ x_eval'(sa*|a*) = s ]|
    with
      sig     := <attribute-signature>;
      name    := <pattern-to-name-suffix> pattern;
      x_eval' := <conc-strings; newname> (x_eval, name, "-", <as-string> index);
      sig'    := <rename-signature(|x_eval')> sig;
      rules(        
        OrderedRuleDefs  :+  sig -> sig'
        OrderedRuleIndex :   sig' -> index
      )
  
  make-merged-def-root:
    |[ x_eval(sa*|a*) = s ]| -> |[ x_eval-root(sa*|a*) = s ]|
    with
      sig         := <attribute-signature>;
      x_eval-root := <conc-strings; newname> (x_eval, "-root");
      sig'        := <rename-signature(|x_eval-root)> sig;
      rules(
        OrderedRuleDefs  :+ sig -> sig'
        OrderedRuleIndex :  sig' -> ROOT_RULE_INDEX()
      )
  
  make-merged-def-default:
    |[ x_eval(sa*|a*) = s ]| -> |[ x_eval-default(sa*|a*) = s ]|
    with
      ?eval;
      sig            := <attribute-signature> eval;
      x_eval-default := <default-rule-name> eval;
      sig'           := <rename-signature(|x_eval-default)> sig;
      rules(
        OrderedRuleDefs  :+ sig -> sig'
        OrderedRuleIndex :  sig' -> DEFAULT_RULE_INDEX()
      )
  
  pattern-to-name-suffix =
    (?NoAnnoList(Op(<id>, _)) + ?AnnoList(Op(<id>, _), _));
    <conc-strings> ("-", <id>)
  <+
    !""
  
  record-def(|accessor-type) =
    ?|[ x_eval(sa*|a*) = s ]|;
    sig := <attribute-signature>;
    
    if not(IsKnownRule) then
      rules(
        AllRules         :+= sig
        IsKnownRule      :   sig
        RuleAccessorName :   sig -> x_eval
        RuleParams       :   sig -> (sa*, a*)
        RuleAccessorType :   sig -> accessor-type
      )
    end
  
  // TODO: Higher ordering penalty for deep child patterns?
  
  /**
   * Determine a priority number for a given semantic rule pattern.
   * (Rules with higher values are tried first.)
   */
  pattern-order-index(|child):
    pattern -> <add> (<add> (ops, tails), bonus)
    where
      ops   := <length> <collect-all(?AnnoList(_, _) + ?NoAnnoList(_))> pattern;
      tails := <length> <collect-all(?ListTail(_, _))> pattern; // [_|_] > [_]
      bonus := <!child => NoChild() < !NO_CHILD_INDEX() + !0>

