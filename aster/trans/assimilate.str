module assimilate

imports
  Stratego-Attributes
  stratego-rerag
  default-attributes
  util
  rule-merging
  rule-defaults

overlays
  /**
   * The number of fixed arguments present in each attribute evaluation strategy.
   */
  AG_STANDARD_ARGS = 4

strategies

  assimilate-all =
    init-shared-vars;
    add-imports;
    
    all-stratego-defs(try(
      assimilate-def
    ));
    
    topdown(try(
      assimilate-expr
    ));
    
    add-default-rules;
    add-merged-rules
 
  init-shared-vars =
    // TODO2: Things like <all-parents> should be optimized in a post-processing stage, not right away
    // TODO2: Rename attr-cache to cache or store, or something
    rules(
      ParentVar         := <newname> "parent"
      NodeVar           := <newname> "node"
      AllParentsVar     := <newname> "all-parents"
      AttributeCacheVar := <newname> "attr-cache"
      RewriteModeVar    := <newname> "rewrite-mode"
    )

  add-imports:
    Module(x, decl*) -> Module(x, [imports | decl*])
    with
      imports := |[ imports annotations attributes circular parents lists rewrites debug ]|

  // TODO: Support args in eval functions
  // TODO: Rewrite rules
  // TODO2: runtime check for annotated terms used for/by dynamic rules

  assimilate-def:
    AttributeDef(
      type
    , t_pattern
    , AttributeDefStrategy(child, attr @ Attribute(name, as*, a*), _, s)
    ) ->
    <make-merged-def(|attr, t_pattern, child, type-name)>
    Def |[
      x_eval(as* |x_parent, x_all-parents, x_attr-cache, x_rewrite-mode, a'*) =
        ?x_node;
        where(s_init-args);
        s_pattern;
        s'
    ]|
    with
      x_parent           := <ParentVar>;
      x_node             := <NodeVar>;
      x_all-parents      := <AllParentsVar>;
      x_attr-cache       := <AttributeCacheVar>;
      x_rewrite-mode     := <RewriteModeVar>;
      type-name          := <attribute-type-name(|type)> attr;
      sig                := <attribute-signature> attr;
      x_eval             := <attribute-accessor-name(|type-name)> attr;
      (a'*, s_init-args) := <extract-arg-patterns> a*;
      
      s_parent         := |[ ?x_node; !x_parent; not(UnknownParent)
                             <+ get-parent(|x_all-parents) ]|;
      s_parent-desired := |[ ?x_node < !x_parent + !UnknownParent() ]|;
      
      if NoChild() := child then
        Root()    := t_pattern;
        s_pattern := <root-pattern(|x_parent, x_all-parents)>
      <+
        s_pattern := |[ ?t_pattern ]|
      else // Inherited attribute
        Child(child') := child;
        s_pattern     := <ancestor-check(|child', x_parent, x_all-parents)> t_pattern
      end;
      
      !s;
      topdown(try(
        assimilate-expr-inside-ag(|sig, s_parent, s_parent-desired, x_node, x_all-parents, x_attr-cache)
      ));
      add-eval-failed => s'
   
   assimilate-def:
     AttributeDecl(_, _, _, _) -> []
   
   root-pattern(|x_parent, x_all-parents) =
     !|[ where(
          UnknownParent() := x_parent
            < get-parent(|x_all-parents); NoParent
            + <NoParent> x_parent
         )
     ]|
   
   // TODO: Apply anonymous rewrite rules
   
   assimilate-def:
     AnonymousRewriteRule(t_pattern, t_after, s_where) ->
     |[ eval-anonymous-rewrite =
          ?x_before;
          
          ?t_pattern;
          where(s_where);
          !t_after;
          
          s_trace
     ]|
     with
       x_before       := <NodeVar>;
       s_trace        := <trace-rewrite>

rules // Argument patterns
  
  extract-arg-patterns =
    unzip(extract-arg-pattern);
    (id, fold-seq)
  
  extract-arg-pattern:
    t -> (DefaultVarDec(x_name), |[ t' := x_name ]|)
    with
      t'     := <alltd(match-var-ignore-annos)> t; // don't care about annos
      x_name := <newname> "arg"
  
  match-var-ignore-annos:
    Var(x) ->
    Term |[
      <(id < id + ?x); // x may be bound or not; turn off compiler complaints
       (?x <+ eq-ignore-annos(|x))>
    ]| 

rules // Semantic rule definition helpers

  add-eval-failed:
    Seq(WhereClause(s1), s2) -> |[ where(s1); (s2 <+ !EvalFailed()) ]|
  
  add-eval-failed:
    s -> |[ s <+ !EvalFailed() ]|
    where
      not(?Seq(WhereClause(c), _))
  
  /**
   * Match based on an ancestor (e.g., for inh Foo(Bar(x)).x).
   */
  ancestor-check(|x_child, x_parent, x_all-parents):
    t_pattern ->
    |[ ?x_child;
        where(
          (!x_parent; not(UnknownParent) <+ s_traverse-up);
          s_traverse-up';
          ?t_pattern
        )
    ]|
    with
      depth          := <dec> <term-depth(|Var(x_child))> t_pattern;
      s_traverse-up  := |[ get-parent(|x_all-parents); not(NoParent) ]|;
      s_traverse-up' := <copy; fold-seq> (depth, s_traverse-up)
    
    // TODO2: Optimize - ancestor-check should use intermediate patterns

strategies // Attribute strategy naming

  attribute-type-name(|local-type) =
    if NoType() := local-type then
      attribute-type // globally declared type
    else
      !local-type
    end;
    
    switch id
      case Inh():   !"inh"
      case Local(): !"local"
      otherwise:    !"syn"
    end

  attribute-accessor-name(|type):
    Attribute(name, _, _) -> accessor
    with
      accessor  := <conc-strings> ("eval-", type, "-", name)
  
  preferred-attribute-accessor-type =
    attribute-type-name(|NoType())

rules // Evaluate attributes in AG context

  assimilate-expr-inside-ag(|sig, s_parent, s_parent-desired, x_node, x_all-parents, x_attr-cache) =
    assimilate-native-ref-inside-ag(|s_parent, x_all-parents, x_node, x_attr-cache)
  <+
    assimilate-native-ref
  <+
    ?AttributeRef(_, attr);
    assimilate-attr-ref-inside-ag(|s_parent, s_parent-desired, x_all-parents, x_node, x_attr-cache);
    try(
      assimilate-attr-self-ref-inside-ag(|sig, attr, s_parent, x_node)
    )
   
  assimilate-attr-ref-inside-ag(|s_parent, s_parent-desired, x_all-parents, x_node, x_attr-cache):
    AttributeRef(t, attr @ Attribute(name, s*, t*)) ->
    Strat |[ <s> t ]|
    with
      type           := <preferred-attribute-accessor-type> attr;
      x_eval         := <attribute-accessor-name(|type)> attr;
      x_rewrite-mode := <RewriteModeVar>;
      if "inh" := type then
        s := |[ x_eval(s* |<s_parent>,         x_all-parents, x_attr-cache, x_rewrite-mode, t*) ]|
      else
        // Pass current node as a parent, or pass UnknownParent
        s := |[ x_eval(s* |<s_parent-desired>, x_all-parents, x_attr-cache, x_rewrite-mode, t*) ]|
      end

  /**
   * Adjust references to attributes to avoid circular references
   * (e.g., 'inh foo = id.foo' becomes '... = id.parent.foo').
   */
  assimilate-attr-self-ref-inside-ag(|sig, attr, s_parent, x_node):
    s_eval ->
    Strat |[
      (?x_node < s_parent; not(NoParent) + id);
      s_eval
    ]|
    where
      <attribute-signature> attr => sig;
      <attribute-type> attr => Inh()

rules // Evaluate attributes outside of AG context

  // TODO: Don't eagerly get parent reference

  assimilate-expr =
    assimilate-native-ref
  <+
    assimilate-attr-ref

  // TODO2: Optimize - use local variables to cache all <attribute-cache> and <all-parents> calls

  assimilate-attr-ref:
    AttributeRef(t, attr @ Attribute(name, s*, t*)) ->
    Strat |[
      !t;
      astr-initialize-node-ensure(
        astr-initialize-node-warning(|~str:name')
      | <all-parents => x_all-parents>
      , <attribute-cache => x_attr-cache>
      );
      x_eval(s* |UnknownParent(), x_all-parents, x_attr-cache, <get-rewrite-mode(|x_attr-cache)>, t*)
    ]|
    with
      type           := <attribute-type-name(|NoType())> attr;
      x_eval         := <attribute-accessor-name(|type)> attr;
      x_all-parents  := <newname> "all-parents";
      x_attr-cache   := <newname> "attr-cache";
      name'          := name
        
      