module rule-merging

imports
  libstratego-lib
  util
  rule-tracing
  rule-caching
  rule-circularity
  assimilate
  analyze

overlays
  DEFAULT_RULE_INDEX = -1
  ROOT_RULE_INDEX    = 100000
  HAS_CHILD_INDEX    = 10000

strategies
  
  // TODO: Cheap circularity detection using counter argument?
  // TODO2: Optimize - inline rule defs in ordered rule defs?
  
  add-merged-rules:
    Module(x, decl*) -> Module(x, [decl*, ordered*])
    where
      bagof-AllRules;
      map({
        ?def;
        add-merged-rule;
        try(make-circular-rule(|def))
      });
      flatten-list;
      ordered* := [Rules(<id>)]
  
  // TODO2: Optimize - don't cache the copy rules?
  
  add-merged-rule:
    def @ Attribute(x_eval, sarity, tarity) ->
    |[ x_eval(as*|a*) =
         s_cache-read
       <+
         s_rewrite;
         s_trace;
         ?x_node;
         s;
         if EvalFailed then
           s_cache-write;
           !x_node;
           s_trace-failed;
           fail
         else
           astr-initialize-node-prefer(|x_all-parents, x_attr-cache);
           s_cache-write
         end
    ]|
    with
      (as*, a*)      := <RuleArgs> def;
      (s*, t*)       := <params-to-args> (as*, a*);
      x_all-parents  := <AllParentsVar>;
      x_attr-cache   := <AttributeCacheVar>;
      x_node         := <NodeVar>;
      defs           := <sort-ordered-defs> <make-set> <bagof-OrderedRuleDefs> def;
      s              := <fold-lchoice> <map(def-call(|s*, t*))> defs;
      s_trace        := <trace-rule> def;
      s_trace-failed := <trace-failed-rule> def;
      s_cache-read   := <add-cache-read(|s*, t*)> def;
      s_cache-write  := <add-cache-write(|s*, t*, x_node)> def;
      s_rewrite      := <add-rewrite(|x_all-parents, x_attr-cache)>

  // TODO2: Move this
  add-rewrite(|x_all-parents, x_attr-cache) =
    if UsesAnonymousRewriteRules then
      x_rewrite-mode := <RewriteModeVar>;
      !Strat |[
        if 1 := x_rewrite-mode then
          eval-anonymous-rewrites-cached(|x_all-parents, x_attr-cache)
        end
      ]|
    else
      !Strat |[ id ]|
    end

  def-call(|s*, t*):
    Attribute(x_eval, _, _) -> |[ x_eval(s*|t*) ]|

  sort-ordered-defs =
    map(!(<OrderedRuleIndex>, <id>));
    qsort({
      ?((index1, _), (index2, _));
      <gt> (index1, index2)
    });
    map(Snd)

strategies

  make-merged-def(|attribute, pattern, child, accessor-type) =
    with(
      record-def(|attribute, accessor-type)
    );
    if Root() := pattern then
      make-merged-def-root
    else
      make-merged-def(|pattern, <pattern-order-index(|child)> pattern)
    end
  
  make-merged-def(|pattern, index):
    |[ x_eval(as*|a*) = s ]| -> |[ x_eval'(as*|a*) = s ]|
    with
      sig     := <attribute-signature>;
      name    := <pattern-to-name-suffix> pattern;
      x_eval' := <conc-strings; newname> (x_eval, name, "-", <as-string> index);
      sig'    := <rename-signature(|x_eval')> sig;
      rules(        
        OrderedRuleDefs  :+  sig -> sig'
        OrderedRuleIndex :   sig' -> index
      )
  
  make-merged-def-root:
    |[ x_eval(as*|a*) = s ]| -> |[ x_eval-root(as*|a*) = s ]|
    with
      sig         := <attribute-signature>;
      x_eval-root := <conc-strings; newname> (x_eval, "-root");
      sig'        := <rename-signature(|x_eval-root)> sig;
      rules(
        OrderedRuleDefs  :+ sig -> sig'
        OrderedRuleIndex :  sig' -> ROOT_RULE_INDEX()
      )
  
  make-merged-def-default:
    |[ x_eval(as*|a*) = s ]| -> |[ x_eval-default(as*|a*) = s ]|
    with
      sig            := <attribute-signature>;
      x_eval-default := <conc-strings; newname> (x_eval, "-default");
      sig'           := <rename-signature(|x_eval-default)> sig;
      rules(
        OrderedRuleDefs  :+ sig -> sig'
        OrderedRuleIndex :  sig' -> DEFAULT_RULE_INDEX()
      )
  
  pattern-to-name-suffix =
    (?NoAnnoList(Op(<id>, _)) + ?AnnoList(Op(<id>, _), _));
    <conc-strings> ("-", <id>)
  <+
    !""
  
  record-def(|attribute, accessor-type) =
    ?|[ x_eval(as*|a*) = s ]|;
    sig := <attribute-signature>;
    
    if not(IsKnownRule) then
      rules(
        AllRules         :+= sig
        IsKnownRule      :   sig
        RuleArgs         :   sig -> (as*, a*)
        RuleAttribute    :   sig -> attribute
        RuleAccessorType :   sig -> accessor-type
      )
    end
  
  /**
   * Determine a priority number for a given semantic rule pattern.
   * (Rules with higher values are tried first.)
   */
  pattern-order-index(|child):
    pattern -> <add> (ops, bonus)
    where
      ops   := <length> <collect-all(?AnnoList(_, _) + ?NoAnnoList(_))> pattern;
      // vars  := <length> <collect-all(?Var(_))> pattern;
      bonus := <!child => NoChild() < !0 + !HAS_CHILD_INDEX()>
