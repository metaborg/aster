module check

imports
  libstratego-lib
  Stratego-Attributes
  // back/default-attributes

rules

  init-check = id.init

  check-all =
    id.init;
    collect-all(where(id.error + id.warning));
    
    list-loop({
      where(context := <id.pp-context <+ !"">);
      if id.error then
        log(|Error(), <conc-strings> (id.error, context), id.pp)
      else
        where(as-string(id.warning));
        log(|Warning(), <conc-strings> (id.warning, context), id.pp)
      end
    });
      
    if one(id.error) then
      <xtc-exit> 1
    end

attributes
  
  def error:
    Attribute(name, _, _) -> "Undefined attribute referenced"
    where
      not(get-attribute-type + is-native-attribute);
      not(<?Decorator(_)> name)
    
    decorator -> "Undefined attribute decorator referenced"
    where
      is-string;
      id.ancestor(?Decorated(_));
      not(<get-attribute-type> Attribute(Decorator(decorator), [1], []))
    
    AttributeDef(_, _, _) -> "Attribute type not declared"
    where
      NoType() := id.def-type
    
    amb(_) -> "Internal error: ambiguity in input"
    
    AttributeDefStrategy(Child(x), _, _, _) -> "Child variable not defined by rule pattern"
    where
      not(id.is-pattern-var(|x))
    
    AttributeDefStrategy(_, Attribute(_, _, args), _, _) -> "Strategy applications not allowed in attribute argument patterns"
    where
      <oncetd(?RootApp(_))> args

    AttributeDefStrategy(_, _, Circular(_), _) -> "Circular attributes cannot be decorated"
    where
      id.def-type => Decorated(_)

    AttributeDefStrategy(_, Attribute(Decorator(_), [], _), _, _) -> "Circular attributes must specify a target strategy argument."
        
    AttributeRef(_, _) -> "Illegal attribute reference in match pattern"
    where
      id.in-match
    
    AttributeDef(type, pattern, s) -> "Chained attributes must specify type inh or syn for each definition"
    where
      Chained() := id.def-type;
      <not(Inh + Syn)> type;
      <not(RootApp(Fail()))> pattern
    
    AttributeDef(_, Root(), _) -> "Synthesized attribute cannot have a root definition"
    where
      id.def-type-local => Syn()
    
    AttributeDef(_, Root(), AttributeDefStrategy(Some(_), _, _, _)) -> "Illegal child pattern on root node definition"
    
    AttributeDefStrategy(_, <is-native-attribute>,_ , _) -> "Cannot redefine a native attribute"
    
    // TODO: report error at the declaration site? (id.def-type.parent)
    AttributeDef(not-Local, _, _) -> "Can only assign local definitions to local attribute"
    where
      <not(Local + NoType)> not-Local;
      <Local> id.def-type
    
    AttributeDef(_, _, AttributeDefStrategy(_, Attribute([_ | _], _, _), Circular(_), _)) ->
    "Circular attributes cannot have strategy arguments" 

  def warning:
    Var(x) -> "Performing match using annotated term - use id.eq instead"
    where
      id.in-match;
      not(id.in-pattern + id.is-def-param);
      (id.is-pattern-var(|x) + id.is-def-arg(|x))
  
  // TODO: confirm attribute applicability based on pattern, where possible
  
  // TODO: more checks
  // - check if topdown-depth succeeds for child patterns
  // - no child patterns in strat calls
  // - inh x(kid).foo = kid.foo should be synthesized or local
  // - inh foo(x) = .... ?x -> Warning: should not use annotated terms in match?
  // - congruence in attribute strategy: Foo().x = Bar() always results in a hard failure
  // - inh x := y -> "set default value using root.x := y"
  // - decorators have no sort or pattern spec

attributes

  is-recursive-definition = id // TODO2: is-recursive-definition
  
  def inh in-match:
    Match(t).t         -> id
    Assign(t, _).t     -> id
    AM(_, t).t         -> id
    As(t, _).t         -> id
    Rule(t, _, _).t    -> id
    RuleNoCond(t, _).t -> id
    RootApp(s).s       -> fail
    App(s, _).s        -> fail
    NameDefBlock(_, t, _, _).t      -> id
    AnonymousRewriteRule(s, _, _).s -> id
    AttributeDefStrategy(_, Attribute(_, _, t), _, _).t -> id
  
  def inh in-pattern:
    AttributeDef(_, pattern, _).pattern -> id
  
  def inh is-pattern-var(|var):
    AttributeDef(_, pattern, _) -> <oncetd(id.eq(|Var(var)))> pattern
  
  def inh is-def-arg(|var):
    AttributeDef(_, _, AttributeDefStrategy(_, attr, _, _)) -> <oncetd(id.eq(|Var(var)))> attr

  local is-def-param:
    AttributeDefStrategy(_, Attribute(_, _, t), _, _).t -> id
  
  // TODO2: Proper error pp
  def pp:
    id                   -> <try(attribute-signature); id.uninit>
    Attribute(n, [], []) -> n
  
  def pp-context =
    id.ancestor(?AttributeDef(_, _, <id>));
    ?AttributeDefStrategy(_, <id.pp>, _, _);
    <conc-strings> (" in attribute ", <as-string>)
  
  def inh def-type:
    AttributeDef(_, _, AttributeDefStrategy(_, attr, _, _)) ->  <get-attribute-type> attr
  
  def inh def-type-local:
    AttributeDef(type, _, _) ->  type
  
  // def inh root.has-root-def(|name) = oncetd(AttributeDef(...
