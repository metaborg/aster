/**
 * Aster semantic checks.
 *
 * @author Lennart Kats <lennart add lclnet.nl>
 */
module check

imports
  libstratego-lib
  Stratego-Attributes
  front/analyze

rules

  init-check = id.init

  check-all =
    id.init;
    collect-all(where(id.error + id.warning));
    list-loop({
      where(context := <id.pp-context <+ !"">);
      if id.error then
        log(|Error(), <conc-strings> (id.error, context), id.pp)
      else
        where(as-string(id.warning));
        log(|Warning(), <conc-strings> (id.warning, context), id.pp)
      end
    });
      
    if one(id.error) then
      <xtc-exit> 1
    end

attributes
  
  def after(try(concat-strings)) error:
    Attribute(name, _, _) -> "Undefined attribute referenced"
    where
      not(get-attribute-decorators + is-native-attribute);
      not(is-decorator)
    
    Decorator(name, _, _) -> "Undefined decorator referenced"
    where
      not(get-attribute-decorators)
    
    ADef(Def(), _, ADefStrategy(_, attr, _)).attr -> "Attribute and decorator signature overlap"
    where
      <is-decorator> attr
    
    ADefStrategy(_, attr, _) -> "Semantic rule type not declared using 'def'"
    where
      not(<HasDeclaration> <attribute-signature> attr)
    
    amb(_) -> "Internal error: ambiguity in input"
    
    ADefStrategy(Child(x), _, _) -> "Child variable not defined by rule pattern"
    where
      not(id.is-pattern-var(|x))
  
    ADef(Type(Decorator(), _, _), _, ADefStrategy(_, Attribute(name, _, _), _)) -> "Illegal name for decorator"
    where
      <"def" + "eq" + "decorator"> name
    
    ADefStrategy(_, Attribute(_, _, args), _) -> "Strategy applications not allowed in attribute argument patterns"
    where
      <oncetd(?RootApp(_))> args

    AttributeRef(_, _) -> "Illegal attribute reference in match pattern"
    where
      id.in-match
    
    /* UNDONE: Pre-decorator checks
    ADefStrategy(_, attr, _) -> "Circular attributes cannot be decorated"
    where
      id.def-type => [_ | _];
      <AttributeCircular> attr
    
    ADef(type, pattern, s) -> "Chained attributes must specify type inh or syn for each definition"
    where
      Chained() := id.def-type;
      <not(Inh + Syn)> type;
      <not(RootApp(Fail()))> pattern
    
    ADef(_, Root(), _) -> "Synthesized attribute cannot have a root definition"
    where
      id.def-type-local => Syn()
    
    ADef(_, _, ADefStrategy(_, attr @ Attribute([_ | _], _, _), _)) ->
    "Circular attributes cannot have strategy arguments"
    where
      <AttributeCircular> attr
    */
    
    ADef(_, Root(), ADefStrategy(Child(_), _, _)) -> "Illegal child pattern on root node definition"
    
    ADefStrategy(_, attr, _) -> "Cannot redefine a native attribute"
    where
      <is-native-attribute> attr;
      not(is-decoration-native-attr)

  def warning:
    Var(x) -> "Performing match using annotated term - use id.eq instead"
    where
      id.in-match;
      not(id.in-pattern + id.is-def-param);
      (id.is-pattern-var(|x) + id.is-def-arg(|x))

    AttributeRef(not-Id, Attribute("attribute-name", _, _)) -> "native attribute \"attribute-name\" should be referenced as id.attribute-name"
    where
      <not(RootApp(Id()) + Var(id))> not-Id // can be called on id, or a decorated function

    AttributeRef(not-Id, Attribute("signature", _, _)) -> "native \"signature\" should be referenced as id.signature"
    where
      <not(RootApp(Id()) + Var(id))> not-Id // can be called on id, or a decorated function

    AttributeRef(not-Id, Attribute("global-cache", _, _)) -> "native \"global-cache\" should be referenced as id.global-cache"
    where
      <not(RootApp(Id()))> not-Id // can be called on id, or a decorated function
    
    ADef(_, pattern, ADefStrategy(Child(child), _, _)).child -> "Pattern child equals pattern"
    where
      0 := <term-depth(|Var(child))> pattern
    
  // TODO: confirm attribute applicability based on pattern, where possible
  
  // TODO: more checks
  // - inh foo(x) = .... ?x -> Warning: should not use annotated terms in match?
  // - congruence in attribute strategy: Foo().x = Bar() always results in a hard failure
  // - warn for "name1: name1 -> ... name2 -> ..." if name1 and name2 aren't used
  //   (should probably be := instead!)
  // - warn for rules(...id... -> foo); id does not bind to the current term but acts as a wild card
  // - decorators have no sort or pattern spec

strategies

  is-recursive-definition = id // TODO2: is-recursive-definition

attributes
  
  def down in-match:
    Match(t).t         -> t
    Assign(t, _).t     -> t
    AM(_, t).t         -> t
    As(t, _).t         -> t
    Rule(t, _, _).t    -> t
    RuleNoCond(t, _).t -> t
    RootApp(s).s       -> fail
    App(s, _).s        -> fail
    NameDefBlock(_, t, _).t      -> t
    AnonymousRewriteRule(s, _, _).s -> s
    ADefStrategy(_, Attribute(_, _, t), _).t -> t
  
  def down in-pattern:
    ADef(_, pattern, _).pattern -> pattern
  
  def down is-pattern-var(|var):
    ADef(_, pattern, _) -> <oncetd(id.eq(|Var(var)))> pattern
  
  def down is-def-arg(|var):
    ADef(_, _, ADefStrategy(_, attr, _)) -> <oncetd(id.eq(|Var(var)))> attr

  def is-def-param:
    ADefStrategy(_, Attribute(_, _, t), _).t -> t
  
  // TODO2: Proper error pp
  def uninit pp:
    id                   -> <try(attribute-signature)>
    Attribute(n, [], []) -> n
  
  def string pp-context =
    id.ancestor(?ADef(_, _, <id>));
    ?ADefStrategy(_, <id.pp>, _);
    <conc-strings> (" in attribute ", <as-string>)
  
  // TODO: Rename def-type, def-type-local
  def down def-type:
    ADef(_, _, ADefStrategy(_, attr, _)) ->  <get-attribute-decorators> attr
  
  def down def-type-local:
    ADef(type, _, _) ->  type
  
  // def down root.has-root-def(|name) = oncetd(ADef(...
