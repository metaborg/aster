/**
 * Aster analysis strategies.
 *
 * @author Lennart Kats <lennart add lclnet.nl>
 */
module analyze

imports
  libstratego-lib
  Stratego-Attributes
  back/assimilate

strategies // Analysis
  
  analyze =
    ( ?ADef(Type(type, decorators, sort), _, ADefStrategy(_, attribute, _))
    + ?ADecl(Type(type, decorators, sort), [attribute])
    );
    with(
      sig            := <attribute-signature> attribute;
      old-decorators := <AttributeDecorators <+ ![]> sig;
      decorators'    := <unify-decorators> (decorators, old-decorators);
      
      switch !type
        case Decorator():
          sig' := <decorator-signature> sig;
          rules(
            IsDecorator: sig
            HasDeclaration: sig
            AttributeDecorators: sig' -> <AttributeDecorators> sig
          )
        case Def():
          rules(
            HasDeclaration: sig
          )
        case Eq():
          id
      end;
      rules(
        AttributeDecorators: sig -> decorators'
      )
    )
  
  analyze =
    ?AnonymousRewriteRule(_, _, _);
    rules(
      UsesAnonymousRewriteRules: _
    )
  
  unify-decorators =
    union // TODO: Smart decorator unification
    
strategies // Providing information
  
  get-attribute-decorators =
    attribute-signature;
    AttributeDecorators

  is-decorator =
    where(
      attribute-signature;
      IsDecorator
    )

  has-plain-decorator =
    where(
      ?Decorator("plain", [], [])
    <+
      if HasPlainDecorator => cached then
        1 := cached
      else
        ?node;
        rules(HasPlainDecorator: node -> 0);
        
        get-attribute-decorators;
        fetch(has-plain-decorator);
        
        rules(HasPlainDecorator: node -> 1)
      end
    )
  
  // TODO: Explicit constructors / tuples for attribute signatures
  
  attribute-signature:
    Attribute(name, s*, a*) ->
    <strip-annos> Attribute(name, <length> s*, <length> a*)

  attribute-signature =
    Attribute(id, is-int, is-int)

  attribute-signature:
    |[ x_eval(sa*|a*) = s ]| -> Attribute(x_eval', sarity, tarity)
    with
      x_eval' := <UndoAccessorName> x_eval;
      sarity  := <length> sa*;
      tarity  := <subt> (<length> a*, DEFAULT_ARG_COUNT())
  
  attribute-signature:
    Decorator(name, s*, a*) -> sig
    where
      fake-sig    := Attribute(name, ["decorated" | s*], a*);
      sig         := <attribute-signature> fake-sig;
      IsDecorator
  
  rename-signature(|name'):
    Attribute(name,  s*, a*) ->
    Attribute(name', s*, a*)

strategies // Helpers for accessing the implementing strategy of a decorator

  // Since decorators are attributes with additional system arguments,
  // they must be renamed to avoid confusion with decorators that have
  // the same declared signature.

  decorator-signature =
    attribute-signature;
    Attribute(decorator-accessor-name, <add> (DECORATOR_SARG_COUNT(), <id>), <add> (DECORATOR_TARG_COUNT(), <id>))
  
  decorator-accessor-name =
    DecoratorAccessorName
  <+
    ?attr-name;
    accessor := <newname> <conc-strings> (attr-name, "-decorator");
    rules(
      DecoratorAccessorName: attr-name -> accessor
      IsDecoratorAccessorName: accessor
    )
