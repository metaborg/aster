module analyze

imports
  libstratego-lib
  Stratego-Attributes
  back/assimilate
  back/rule-naming

strategies // Analysis

  analyze =
    ( ?AttributeDef(Type(type, decorators, sort), _, AttributeDefStrategy(_, attribute, _))
    + ?AttributeDecl(Type(type, decorators, sort), attribute)
    );
    with(
      sig            := <attribute-signature> attribute;
      old-decorators := <AttributeDecorators <+ ![]> sig;
      decorators'    := <unify-decorators> (decorators, old-decorators);
      
      switch !type
        case Decorator():
          rules(IsDecorator: sig)
        case Def():
          rules(HasDeclaration: sig)
      end;
      
      rules(
        AttributeDecorators: sig -> decorators'
      )
    )
  
  analyze =
    ?AnonymousRewriteRule(_, _, _);
    rules(
      UsesAnonymousRewriteRules: _
    )
  
  unify-decorators =
    conc // TODO: Smart decorator unification
    
strategies // Providing information
  
  get-attribute-decorators =
    attribute-signature;
    AttributeDecorators

  is-decorator =
    where(
      attribute-signature;
      IsDecorator
    )

  // HACK: work-around to get `plain` attributes for now
  is-plain-decorator =
    where(
      "`plain`"
    <+
      !Attribute(Decorator(<id>), 1, 0);
      AttributeType;
      Decorated(getfirst(?"`plain`"))
    )
  
  // TODO: Explicit constructors / tuples for attribute signatures
  
  attribute-signature:
    Attribute(name, s*, a*) ->
    <strip-annos> Attribute(name, <length> s*, <length> a*)

  attribute-signature =
    Attribute(id, is-int, is-int)

  attribute-signature:
    |[ x_eval(sa*|a*) = s ]| -> Attribute(x_eval', sarity, tarity)
    with
      sarity  := <length> sa*;
      tarity  := <subt> (<length> a*, DEFAULT_ARG_COUNT());
      x_eval' := <try(UndoAccessorName)> x_eval
  
  attribute-signature:
    Decorator(name, s*, a*) -> <attribute-signature> Attribute(name, s*, a*)
  
  rename-signature(|name'):
    Attribute(name,  s*, a*) ->
    Attribute(name', s*, a*)
