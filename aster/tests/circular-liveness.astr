module circular-liveness

imports
  libstratego-lib

// Definition of a small toy language

signature constructors
  While  : Var * List(Stm)             -> Stm
  If     : Var * List(Stm) * List(Stm) -> Stm
  Assign : Var * Var                   -> Stm
  Return : Var                         -> Stm
  String :                                Var

strategies // Set-up, testing

  main-circular-liveness =
    option-wrap(
      verbose-option
    ,
      input := <make-input>;
      
      <test-live-before> input;
      <test-live-after> input
    )
  
  make-input =
    ![ Assign("bogus1", "value")
     , Assign("bogus2", "bogus1")
     , Assign("x", "value")
     , While("x", [
         Assign("x", "bogus3")
       , Assign("x", "value")
       ])
     , Return("x")
    ].init
  
  test-live-before =
    topdown(
      if(id.is-stm, !id{^id.live-before})
    );
    
    ?[ Assign("bogus1", "value")   {          "bogus3", "value"}
     , Assign("bogus2", "bogus1")  {"bogus1", "bogus3", "value"}
     , Assign("x", "value")        {          "bogus3", "value"}
     , While("x", [
         Assign("x", "bogus3")     {          "bogus3", "value"}
       , Assign("x", "value")      {          "bogus3", "value"}
      ])                           {"x",      "bogus3", "value"}
     , Return("x")                 {"x"}
     ];
     
     say(!"live-before matches")
  
  test-live-after =
    topdown(
      if(id.is-stm, !id{^id.live-after})
    );
      
    ?[ Assign("bogus1", "value")   {"bogus1", "bogus3", "value"}
     , Assign("bogus2", "bogus1")  {          "bogus3", "value"}
     , Assign("x", "value")        {"x",      "bogus3", "value"}
     , While("x", [
         Assign("x", "bogus3")     {          "bogus3", "value"}
       , Assign("x", "value")      {"x",      "bogus3", "value"}
       ])                          {"x",      "bogus3", "value"}
     , Return("x")                 {}
     ];
     
     say(!"live-after matches")
  
  local [stm | _].stm.is-stm = not(is-list) // statements are contained by lists

attributes // Local variable use and define sites

  local uses:
    id             -> []
    If(var, _, _)  -> [var]
    While(var, _)  -> [var]
    Assign(_, var) -> [var]
    Return(var)    -> [var]
  
  local defines:
    id             -> []
    Assign(var, _) -> [var]

attributes // Control flow defaults
  
  inh succ-enclosing: // next statement as determined by the enclosing control structures  
    root            -> []
    [s1, s2 | _].s1 -> [s2]

  local succ = id.succ-enclosing // default next statement for a particular statement
  
  local hds: // helper attribute to get the first statement in a list
    id      -> []
    [s | _] -> [s]

attributes // Control flow for specific statements
  
  eq If(e, s1, s2).succ := [s1.hds, s2.hds]
     
  eq While(e, s):
    id.succ           := <conc> (s.hds, id.succ-enclosing)
    id.succ-enclosing := [id]
  
  eq Return(e).succ := []

attributes // Data flow

  local stm circular []:
    id.live-before =
      <id.union> (id.uses, <id.diff> (id.live-after, id.defines))
  
    id.live-after =
      TODO: id.succ.map(id.live-before).union

