testsuite Stratego-Attributes
topsort Decl

test Rules block
   "rules" -> Rules([])

test Assignment in pattern definition block
  "rules
    eq attribute:
      Pattern(x) -> 2 where Foo() :=  x"
->  _
  
test Rule definition vs. attribute pattern definition block
  "rules eq foo: 1 -> 2 eq bar : 3 -> 4"
-> _

test Rule definition vs. attribute pattern definition block (2)
  "rules eq foo: 1 -> 2 syn bar : 3 -> 4"
-> _

test Attribute pattern block with strategy definitions
  "rules
     eq Pattern(child):
       child.bar = !1
       id.baz = !2
  "
-> _

test Empty pattern block and strategy definition
  "rules
     eq Pattern(child):
     
     bar = !1 // not to be confused with id.bar = !1
  "
fails

test Non-empty pattern block and strategy definition
  "rules
     eq Pattern(child):
       id.bar = !1
     
     baz = !1
  "
-> _

test Decorated rule (1)
  "rules
     s = ?a 
     
     `custom` rule : 2 -> 3
  " -> _

test Decorated rule (2)
  "rules
     `custom` Pattern(s): s.x := 3
  " -> _  

test Attribute definition block with variable pattern
  "rules
     local foo:
       id.bar = id
       id.baz = id
  " -> _
  
test Attribute definition block with single strategy
  "rules
     local foo(s):
       id.bar = s
  " -> _
  
test Attribute reference in match
  "rules
     s = ?1.bar
  " -> _
  
test Attribute defined on tuple
  "rules
     eq (1,2,3).foo = !1
  " -> _

test Attribute localfoo
  "rules
     local foo = !1
  " -> _

test Pattern rootfoo
  "rules
     eq rootfoo.bar = !1
  " -> _

test Attribute block defined on tuple
  "rules
     local (a,b):
        a.x := 1
  " -> _

test Attribute on term 'eq'
  "rules
     eq eq = 1
  " -> _

test AttributeDecl and AttributeDefNoPattern
  "rules
     syn x
     eq B(a): id.x = 1
   " -> _

test Attribute definition vs. <App> (1)
  "rules
     s = x := <Foo>
     eq bar = 1
  " -> _

test Attribute definition vs. <App> (2)
  "rules
     s = x := <Foo>
     syn bar = 1
  " -> _

test Attribute reference vs. <App> (1)
  "rules
     s = <foo> 1.bar
  " -> Rules([SDefNoArgs("s",BA(CallNoArgs(SVar("foo")),NoAnnoList(AttributeTerm(AttributeRef(NoAnnoList(Int("1")),AttributeNoArgs("bar"))))))])
  
test Attribute reference vs. <App> (2)
  "rules
     s = <foo> foo.bar
  " -> Rules([SDefNoArgs("s",BA(CallNoArgs(SVar("foo")),NoAnnoList(AttributeTerm(AttributeRef(Var("foo"),AttributeNoArgs("bar"))))))])

test Attribute as annotation list
  "rules
    s = !1{^id.annos}
  " -> _

test Attribute pattern definitions vs. <App> (1)
  "rules
     eq inh:
       1 -> <s>
       A(2) -> 3
  " -> Rules([PatternDefBlock(NoType,AttributeNoArgs("inh"),NotCircular,[AttributePDefTerm(NoAnnoList(Int("1")),NoChild,RootApp(CallNoArgs(SVar("s"))),NoWhere),AttributePDefTerm(NoAnnoList(Op("A",[NoAnnoList(Int("2"))])),NoChild,NoAnnoList(Int("3")),NoWhere)])])

test Attribute pattern definitions vs. <App> (2)
  "rules
     eq inh:
       1 -> <s> A
       (2) -> 3
  " -> Rules([PatternDefBlock(NoType,AttributeNoArgs("inh"),NotCircular,[AttributePDefTerm(NoAnnoList(Int("1")),NoChild,App(CallNoArgs(SVar("s")),Var("A")),NoWhere),AttributePDefTerm(NoAnnoList(Tuple([NoAnnoList(Int("2"))])),NoChild,NoAnnoList(Int("3")),NoWhere)])])

test Attribute pattern definitions vs. <App> (3)
  "rules
     eq inh:
       1 -> <s>
       A
       (2) -> 3
  " -> _ // just has to be unambiguous

test Attribute pattern definitions vs. <App> (4)
  "rules
     eq inh:
       1 -> <s> A (2) -> 3" -> _ // just has to be unambiguous

test Attribute pattern definitions vs. <App> (5)
  "rules
     eq inh:
       1 -> <s> 2 -> 3" fails // not so nice, but just has to be unambiguous


test Attribute pattern definitions vs. <App> (6)
  "rules
     eq inh: 1 -> 2 3 -> 4" -> _

test Attribute pattern definitions vs. <App> (7)
  "rules
     eq inh:
       1 -> <s> A /* foo */ (2) -> 3" -> _ // just has to be unambiguous

test Attribute pattern definitions vs. <App> (8)
  "rules
     eq inh:
       1 -> <s> /* foo */ A (2) -> 3" -> _ // just has to be unambiguous

test Attribute pattern definitions vs. <App> (9)
  "rules
     eq inh: 1 -> <s1;
                   s2> with foo
     bar = 1
  " -> _

test Disallow childless attribute strategy in block
  "rules
     local Pattern(x, y):
       attribute := 3
  " fails

test Attributes in pattern
  "rules
     eq Foo(id.eq(|baz)).bar(|baz) = id
  " -> _

test Mixture of attribute keywords and identifiers
  "rules
     eq `eq` eq = 1" -> _ // could break with future syntax

