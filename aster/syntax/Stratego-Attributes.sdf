module Stratego-Attributes

imports
  Stratego-Sugar
  ResultTerms

hiddens
  context-free start-symbols
    Module
    Decl

exports
  sorts
    AttributeType
    Pattern
    AttributeRef
    AttributeCall
    AttributeCallLHS
    AttributeDecl
    AttributeKeyword
    ChildDot
    DotChild
    DecoratorId
    AttributeId
    AttributeDeclId
    OptChildDot
    OptDotChild
    AttributeNameValue
    NameDefBlockDef
    PatternDefBlockDef
    Circular
    Where
    OptWhere
    NoWhere
  
  %% TODO: New syntax? Eliminate backticks.
  %%
  %% def collect-all foo // decl (or a different keyword? "eq"? "sem"?)
  %% eq foo = 2         // <- error if no accompanying def
  %%
  %% def inh Pattern(x).bar = 3 // <- declaration and definition
  %%
  %% decorator inh collect-all(s) = id.collect-all(s) <+ ...
  
  lexical syntax

    "`" Id "`" -> DecoratorId
    "all"      -> AttributeId %% reserved Id
    "one"      -> AttributeId %% reserved Id
    "some"     -> AttributeId %% reserved Id
 
  context-free syntax
  
    Id -> AttributeId {prefer}
  
  context-free syntax %% attributes
  
    AttributeId -> AttributeDeclId
    DecoratorId -> AttributeDeclId {cons("Decorator")}
    
    AttributeDeclId "(" { Typedid "," }* "|" { Term "," }* ")" -> AttributeDecl {cons("Attribute")}
    AttributeDeclId "(" { Typedid "," }*                   ")" -> AttributeDecl {cons("AttributeNoTerms")}
    AttributeDeclId                                            -> AttributeDecl {cons("AttributeNoArgs")}
    
    AttributeId "(" { Strategy "," }* "|" { Term "," }* ")" -> AttributeRef {cons("Attribute")}
    AttributeId "(" { Strategy "," }*                   ")" -> AttributeRef {cons("AttributeNoTerms")}
    AttributeId                                             -> AttributeRef {cons("AttributeNoArgs")}

    AttributeCallLHS "." AttributeRef -> AttributeCall {cons("AttributeRef")}
    Term                              -> AttributeCallLHS
    "<" Strategy ">" Term             -> AttributeCallLHS {reject}
    
    AttributeCall -> Strategy {prefer}
    AttributeCall -> PreTerm {cons("AttributeTerm")}
   
  context-free syntax %% semantic rules: core syntax

    AttributeType Pattern "." AttributeNameValue     -> RuleDef {cons("AttributeDef")}
    AttributeType Pattern "." AttributeDecl Circular -> RuleDef {cons("AttributeDecl")}

    OptChildDot AttributeDecl Circular "="  Strategy -> AttributeNameValue {cons("AttributeDefStrategy")}
    
    Id "."     -> ChildDot {cons("Child")}
    "." Id     -> DotChild {cons("DotChild")}
    "id" "."   -> ChildDot {cons("IdChild"), prefer}    %% sugar
    "." "id"   -> DotChild {cons("DotIdChild"), prefer} %% sugar
    "root" "." -> ChildDot {reject}
    "." "root" -> DotChild {reject}
    
    ChildDot   -> OptChildDot
               -> OptChildDot {cons("NoChild")}
    DotChild   -> OptDotChild
               -> OptDotChild {cons("NoChild")}

    %% Patterns are terms without attribute references
    
    Term          -> Pattern
    AttributeCall -> Pattern {reject}
    "root"        -> Pattern {cons("Root"), prefer}

  context-free syntax %% attribute types
  
    "syn"        -> AttributeType {cons("Syn")}
    "inh"        -> AttributeType {cons("Inh")}
    "local"      -> AttributeType {cons("Local")}
    "chained"    -> AttributeType {cons("Chained")}
    "eq"         -> AttributeType {cons("NoType")}
    DecoratorId+ -> AttributeType {cons("Decorated")}
    
    AttributeKeyword                       -> Pattern {reject}
%%  AttributeKeyword "(" { Term "," }* ")" -> Pattern {reject}

%%  Either reject suffices, but the first may be too specific
%%  "<" Strategy ">" AttributeKeyword -> Term {reject}
    AttributeKeyword -> Var {reject}

    "circular" Term -> Circular {cons("Circular")}
    "circular"      -> Circular {cons("CircularFail")}
                    -> Circular {cons("NotCircular")}
  
  lexical syntax
    
    "eq"      -> AttributeKeyword
    "syn"     -> AttributeKeyword
    "inh"     -> AttributeKeyword
    "local"   -> AttributeKeyword
    "chained" -> AttributeKeyword
  
  context-free restrictions
  
    "eq"
    "syn"
    "inh"
    "root"
    "local"
    "chained"
    "circular"
    "attributes" -/- [a-zA-Z0-9\'\-\_]

  context-free syntax %% semantic rules: syntactic sugar
 
    "attributes" Def* -> Decl {cons("Attributes")}    

    %% Single-line attribute definitions
    AttributeType AttributeNameValue                      -> RuleDef {cons("AttributeDefNoPattern"), avoid}
    AttributeType AttributeDecl Circular                  -> RuleDef {cons("AttributeDeclNoPattern")}
    OptChildDot AttributeDecl Circular ":=" Term OptWhere -> AttributeNameValue {cons("AttributeDefTerm")}
    
    %% Attribute definition blocks/groups
    AttributeType Pattern Circular       ":"
    NameDefBlockDef+                         -> RuleDef {cons("NameDefBlock")}
    AttributeType AttributeDecl Circular ":"
    PatternDefBlockDef+                      -> RuleDef {cons("PatternDefBlock")}
    
    %% Definitions grouped in a NameDefBlock
    ChildDot AttributeDecl Circular ":=" Term OptWhere -> NameDefBlockDef {cons("AttributeDefTerm")}
    ChildDot AttributeDecl Circular "="  Strategy      -> NameDefBlockDef {cons("AttributeDefStrategy")}

    %% Definitions grouped in a PatternDefBlock
    Pattern OptDotChild "->" ResultTerm NoWhere -> PatternDefBlockDef {cons("AttributePDefTerm")}
    Pattern OptDotChild "->" Term       Where   -> PatternDefBlockDef {cons("AttributePDefTerm")}

    "where" Strategy                 -> Where {cons("WhereClause")}
    "with" Strategy                  -> Where {cons("WithClause")}
    "where" Strategy "with" Strategy -> Where {cons("WhereWithClause")}

    %% TODO: Allow lists of where/with clauses

            -> NoWhere {cons("NoWhere")}
    NoWhere -> OptWhere
    Where   -> OptWhere

  context-free syntax
      
    DecoratorId "(" Strategy ")" -> AttributeCall {cons("DecoratorRef")}

  context-free syntax %% Misc.
    
    "eq" Pattern "->" Term "where" Strategy -> RuleDef {cons("AnonymousRewriteRule")}
    "eq" Pattern "->" Term                  -> RuleDef {cons("AnonymousRewriteRuleNoWhere")}
      
    "id"   -> PreTerm {cons("IdTerm")}
    "fail" -> Term {cons("FailTerm")}
 
    %% "extend" TermPrototype ":" { TermPrototype }+ -> ExtendId
