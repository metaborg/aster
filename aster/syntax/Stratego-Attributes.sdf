module Stratego-Attributes

imports
  Stratego-Sugar
  ResultTerms

hiddens
  context-free start-symbols
    Module
    Decl

exports
  sorts
    DefType
    Pattern
    AttributeDef
    AttributeRef
    AttributeCall
    AttributeCallLHS
    AttributeDecl
    AttributeType
    DecoratorRef
    DecoratorId
    AttributeKeyword
    ChildDot
    DotChild
    AttributeId
    AttributeDeclId
    OptChildDot
    OptDotChild
    OptSortDot
    AttributeNameValue
    NameDefBlockDef
    PatternDefBlockDef
    Where
    NoWhere
    UNDEFINED %% matches nothing
  
  lexical syntax

    "all"  -> AttributeId %% reserved Id
    "one"  -> AttributeId %% reserved Id
    "some" -> AttributeId %% reserved Id
    "signature" -> AttributeId %% reserved Id
  
  context-free restrictions
  
    AttributeId -/- [a-zA-Z0-9\'\-\_\*]

    DecoratorRef -/- [\(]  %% decorator(arg,y) vs. decorator (tuple, y)
  
  context-free syntax
  
    Id               -> AttributeId {prefer}

    AttributeKeyword -> DecoratorId {reject}
    AttributeId      -> DecoratorId
    "*"              -> DecoratorId
    "plain"          -> DecoratorId {prefer} %% treat as keyword
  
  context-free syntax %% attributes
  
    AttributeId -> AttributeDeclId
    
    AttributeDeclId "(" { Typedid "," }* "|" { Term "," }* ")" -> AttributeDecl {cons("Attribute")}
    AttributeDeclId "(" { Typedid "," }*                   ")" -> AttributeDecl {cons("AttributeNoTerms")}
    AttributeDeclId                                            -> AttributeDecl {cons("AttributeNoArgs")}
    
    AttributeId "(" { Strategy "," }* "|" { Term "," }* ")" -> AttributeRef {cons("Attribute")}
    AttributeId "(" { Strategy "," }*                   ")" -> AttributeRef {cons("AttributeNoTerms")}
    AttributeId                                             -> AttributeRef {cons("AttributeNoArgs")}
    
    DecoratorId "(" { Strategy "," }* "|" { Term "," }* ")" -> DecoratorRef {cons("Decorator")}
    DecoratorId "(" { Strategy "," }*                   ")" -> DecoratorRef {cons("DecoratorNoTerms")}
    DecoratorId                                             -> DecoratorRef {cons("DecoratorNoArgs")}

    AttributeCallLHS "." AttributeRef -> AttributeCall {cons("AttributeRef")}
    Term                              -> AttributeCallLHS
    "<" Strategy ">" Term             -> AttributeCallLHS {reject}
    
    AttributeCall -> Strategy {prefer}
    AttributeCall -> PreTerm {cons("AttributeTerm")}
   
  context-free syntax %% semantic rules: core syntax

    AttributeType { AttributeDecl "," } +        -> AttributeDef {cons("AttributeDecl")}
    AttributeTypeNoSort Pattern "." AttributeNameValue -> AttributeDef {cons("AttributeDef")}
    
    DefType DecoratorRef* OptSortDot -> AttributeType {cons("Type")}
    DefType DecoratorRef* NoSortDot -> AttributeTypeNoSort {cons("Type")}
    
    OptChildDot AttributeDecl "="  Strategy -> AttributeNameValue {cons("AttributeDefStrategy")}
    
    "eq"        -> DefType {cons("Eq")}
    "def"       -> DefType {cons("Def")}
    "decorator" -> DefType {cons("Decorator")}
    
    Id "."     -> ChildDot {cons("Child")}
    "." Id     -> DotChild {cons("DotChild")}
    "id" "."   -> ChildDot {cons("IdChild"), prefer}    %% sugar
    "." "id"   -> DotChild {cons("DotIdChild"), prefer} %% sugar
    "root" "." -> ChildDot {reject}                     %% confusing
    "." "root" -> DotChild {reject}                     %% confusing
    
    ChildDot   -> OptChildDot
               -> OptChildDot {cons("NoChild")}
    DotChild   -> OptDotChild
               -> OptDotChild {cons("NoChild")}
    
    Sort "." -> OptSortDot {cons("Sort")}
             -> OptSortDot {cons("NoSort")}
             -> NoSortDot {cons("NoSort")}
    
    Term             -> Pattern
    AttributeKeyword -> Pattern {reject}
    AttributeCall    -> Pattern {reject}
    "root"           -> Pattern {cons("Root"), prefer}

  context-free syntax %% semantic rules: syntactic sugar
 
    "attributes" AttributeDef* -> Decl {cons("Attributes")}    
    "decorators" AttributeDef* -> Decl {cons("Decorators")}    

    %% Single-line attribute definitions
    AttributeTypeNoSort AttributeNameValue     -> AttributeDef {cons("AttributeDefNoPattern"), avoid}
    OptChildDot AttributeDecl ":=" Term Where* -> AttributeNameValue {cons("AttributeDefTerm")}
    
    %% Attribute definition blocks/groups
    AttributeType Pattern       ":" NameDefBlockDef+    -> AttributeDef {cons("NameDefBlock")}
    AttributeType AttributeDecl ":" PatternDefBlockDef+ -> AttributeDef {cons("PatternDefBlock")}
    
    %% Definitions grouped in a NameDefBlock
    ChildDot AttributeDecl ":=" Term     Where* -> NameDefBlockDef {cons("AttributeDefTerm")}
    ChildDot AttributeDecl "="  Strategy        -> NameDefBlockDef {cons("AttributeDefStrategy")}

    %% Definitions grouped in a PatternDefBlock
    Pattern OptDotChild "->" ResultTerm NoWhere* -> PatternDefBlockDef {cons("AttributePDefTerm")}
    Pattern OptDotChild "->" Term       Where+   -> PatternDefBlockDef {cons("AttributePDefTerm")}

    "where" Strategy -> Where {cons("Where")}
    "with" Strategy  -> Where {cons("With")}
    UNDEFINED        -> NoWhere

  context-free syntax %% Misc.
    
    "rewrite" Pattern "->" Term Where* -> AttributeDef {cons("AnonymousRewriteRule")}
      
    "id"   -> PreTerm {cons("IdTerm")}
    "fail" -> Term {cons("FailTerm")}

  context-free syntax

    %%  Either reject suffices, but the first may be too specific/confusing
    %%  "<" Strategy ">" AttributeKeyword -> Term {reject}
    AttributeKeyword -> Var {reject}
  
  lexical syntax
    
    "eq"        -> AttributeKeyword
    "def"       -> AttributeKeyword
    "decorator" -> AttributeKeyword
    "rewrite"   -> AttributeKeyword
  
  context-free restrictions
  
    "eq"
    "def"
    "root"
    "rewrite"
    "decorator"
    "attributes" -/- [a-zA-Z0-9\'\-\_]

