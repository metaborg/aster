module Stratego-Attributes

imports
  Stratego-Sugar
  ResultTerms

hiddens
  context-free start-symbols Module

exports
  sorts
    AttributeType
    Pattern
    AttributeRef
    AttributeCall
    AttributeCallLHS
    AttributeDecl
    AttributeKeyword
    ChildDot
    DotChild
    DecoratorId
    AttributeDeclId
    OptChildDot
    OptDotChild
    AttributeNameValue
    NameDefBlockDef
    PatternDefBlockDef
    Circular
    Where
  
  lexical syntax
  
    "`" Id "`" -> DecoratorId
  
  context-free syntax %% attributes
  
    Id          -> AttributeDeclId
    DecoratorId -> AttributeDeclId {cons("Decorator")}
    
    AttributeDeclId "(" { Typedid "," }* "|" { Term "," }* ")" -> AttributeDecl {cons("Attribute")}
    AttributeDeclId "(" { Typedid "," }*                   ")" -> AttributeDecl {cons("AttributeNoTerms")}
    AttributeDeclId                                            -> AttributeDecl {cons("AttributeNoArgs")}
    
    Id "(" { Strategy "," }* "|" { Term "," }* ")" -> AttributeRef {cons("Attribute")}
    Id "(" { Strategy "," }*                   ")" -> AttributeRef {cons("AttributeNoTerms")}
    Id                                             -> AttributeRef {cons("AttributeNoArgs")}

    AttributeCallLHS "." AttributeRef -> AttributeCall {cons("AttributeRef")}
    Term                              -> AttributeCallLHS
    "<" Strategy ">" Term             -> AttributeCallLHS {reject}
    
    AttributeCall -> Strategy {prefer}
    AttributeCall -> PreTerm {cons("AttributeTerm")}
   
  context-free syntax %% semantic rules: core syntax

    AttributeType Pattern "." AttributeNameValue     -> RuleDef {cons("AttributeDef")}
    AttributeType Pattern "." AttributeDecl Circular -> RuleDef {cons("AttributeDecl")}

    OptChildDot AttributeDecl Circular "="  Strategy -> AttributeNameValue {cons("AttributeDefStrategy")}
    
    Id "."     -> ChildDot {cons("Child")}
    "." Id     -> DotChild {cons("DotChild")}
    "id" "."   -> ChildDot {cons("IdChild"), prefer}    %% sugar
    "." "id"   -> DotChild {cons("DotIdChild"), prefer} %% sugar
    "root" "." -> ChildDot {reject}
    "." "root" -> DotChild {reject}
    
    ChildDot   -> OptChildDot
               -> OptChildDot {cons("NoChild")}
    DotChild   -> OptDotChild
               -> OptDotChild {cons("NoChild")}

    %% Patterns are terms without attribute references
    
    Term          -> Pattern
    AttributeCall -> Pattern {reject}
    "root"        -> Pattern {cons("Root"), prefer}

  context-free syntax %% attribute types
  
    "syn"        -> AttributeType {cons("Syn")}
    "inh"        -> AttributeType {cons("Inh")}
    "local"      -> AttributeType {cons("Local")}
    "chained"    -> AttributeType {cons("Chained")}
    "eq"         -> AttributeType {cons("NoType")}
    DecoratorId+ -> AttributeType {cons("Decorated")}
    
    AttributeKeyword                       -> Pattern {reject}
%%  AttributeKeyword "(" { Term "," }* ")" -> Pattern {reject}

%%  Either reject suffices, but the first may be to specific
%%  "<" Strategy ">" AttributeKeyword -> Term {reject}
    AttributeKeyword -> Var {reject}

    "circular" Term -> Circular {cons("Circular")}
    "circular"      -> Circular {cons("CircularFail")}
                    -> Circular {cons("NotCircular")}
  
  lexical syntax
    
    "eq"      -> AttributeKeyword
    "syn"     -> AttributeKeyword
    "inh"     -> AttributeKeyword
    "local"   -> AttributeKeyword
    "chained" -> AttributeKeyword
  
  context-free restrictions
  
    "eq"
    "syn"
    "inh"
    "root"
    "local"
    "chained"
    "circular"
    "attributes" -/- [a-zA-Z0-9\'\-\_]

  context-free syntax %% semantic rules: syntactic sugar
 
    "attributes" Def* -> Decl {cons("Attributes")}    

    %% Single-line attribute definitions
    AttributeType AttributeNameValue                   -> RuleDef {cons("AttributeDefNoPattern"), avoid}
    AttributeType AttributeDecl Circular               -> RuleDef {cons("AttributeDeclNoPattern")}
    OptChildDot AttributeDecl Circular ":=" Term Where -> AttributeNameValue {cons("AttributeDefTerm")}
    
    %% Attribute definition blocks/groups
    AttributeType Pattern Circular       ":"
    NameDefBlockDef+                         -> RuleDef {cons("NameDefBlock")}
    AttributeType AttributeDecl Circular ":"
    PatternDefBlockDef+                      -> RuleDef {cons("PatternDefBlock")}
    
    %% Definitions grouped in a NameDefBlock
    ChildDot AttributeDecl Circular ":=" Term Where -> NameDefBlockDef {cons("AttributeDefTerm")}
    ChildDot AttributeDecl Circular "="  Strategy   -> NameDefBlockDef {cons("AttributeDefStrategy")}

    %% Definitions grouped in a PatternDefBlock
    Pattern OptDotChild "->" ResultTerm Where -> PatternDefBlockDef {cons("AttributePDefTerm")}

    "where" Strategy                 -> Where {cons("WhereClause")}
    "with" Strategy                  -> Where {cons("WithClause")}
    "where" Strategy "with" Strategy -> Where {cons("WhereWithClause")}

  context-free syntax
      
    DecoratorId "(" Strategy ")" -> AttributeCall {cons("DecoratorRef")}

  context-free syntax %% Misc.
    
    "eq" Pattern "->" Term "where" Strategy -> RuleDef {cons("AnonymousRewriteRule")}
    "eq" Pattern "->" Term                  -> RuleDef {cons("AnonymousRewriteRuleNoWhere")}
      
    "id"   -> PreTerm {cons("IdTerm")}
    "fail" -> Term {cons("FailTerm")}
 
    %% "extend" TermPrototype ":" { TermPrototype }+ -> ExtendId

