module Stratego-Attributes

imports
  Stratego-Sugar
  ResultTerms

hiddens
  context-free start-symbols
    Module
    Decl

exports
  sorts
    DefType
    Pattern
    AttributeRef
    AttributeCall
    AttributeCallLHS
    AttributeDecl
    AttributeKeyword
    ChildDot
    DotChild
    AttributeId
    AttributeDeclId
    OptChildDot
    OptDotChild
    OptSortDot
    AttributeNameValue
    NameDefBlockDef
    PatternDefBlockDef
    Where
    NoWhere
  
  lexical syntax

    "all"  -> AttributeId %% reserved Id
    "one"  -> AttributeId %% reserved Id
    "some" -> AttributeId %% reserved Id
  
  context-free syntax
  
    Id -> AttributeId {prefer}
  
  context-free syntax %% attributes
  
    AttributeId -> AttributeDeclId
    
    AttributeDeclId "(" { Typedid "," }* "|" { Term "," }* ")" -> AttributeDecl {cons("Attribute")}
    AttributeDeclId "(" { Typedid "," }*                   ")" -> AttributeDecl {cons("AttributeNoTerms")}
    AttributeDeclId                                            -> AttributeDecl {cons("AttributeNoArgs")}
    
    AttributeId "(" { Strategy "," }* "|" { Term "," }* ")" -> AttributeRef {cons("Attribute")}
    AttributeId "(" { Strategy "," }*                   ")" -> AttributeRef {cons("AttributeNoTerms")}
    AttributeId                                             -> AttributeRef {cons("AttributeNoArgs")}

    AttributeCallLHS "." AttributeRef -> AttributeCall {cons("AttributeRef")}
    Term                              -> AttributeCallLHS
    "<" Strategy ">" Term             -> AttributeCallLHS {reject}
    
    AttributeCall -> Strategy {prefer}
    AttributeCall -> PreTerm {cons("AttributeTerm")}
   
  context-free syntax %% semantic rules: core syntax

    "def"   Id* OptSortDot AttributeDecl                  -> RuleDef {cons("AttributeDecl")}
    DefType Id* OptSortDot Pattern "." AttributeNameValue -> RuleDef {cons("AttributeDef")}
    
    OptChildDot AttributeDecl "="  Strategy -> AttributeNameValue {cons("AttributeDefStrategy")}
    
    "eq"        -> DefType {cons("Eq")}
    "def"       -> DefType {cons("Def")}
    "decorator" -> DefType {cons("Decorator")}
    
    Id "."     -> ChildDot {cons("Child")}
    "." Id     -> DotChild {cons("DotChild")}
    "id" "."   -> ChildDot {cons("IdChild"), prefer}    %% sugar
    "." "id"   -> DotChild {cons("DotIdChild"), prefer} %% sugar
    "root" "." -> ChildDot {reject}                     %% confusing
    "." "root" -> DotChild {reject}                     %% confusing
    
    ChildDot   -> OptChildDot
               -> OptChildDot {cons("NoChild")}
    DotChild   -> OptDotChild
               -> OptDotChild {cons("NoChild")}
    
    Sort "." -> OptSortDot {cons("Sort")}
             -> OptSortDot {cons("NoSort")}
    
    Term             -> Pattern
    AttributeKeyword -> Pattern {reject}
    AttributeCall    -> Pattern {reject}
    "root"           -> Pattern {cons("Root"), prefer}

  context-free syntax %% semantic rules: syntactic sugar
 
    "attributes" Def* -> Decl {cons("Attributes")}    

    %% Single-line attribute definitions
    DefType Id* AttributeNameValue             -> RuleDef {cons("AttributeDefNoPattern"), avoid}
    OptChildDot AttributeDecl ":=" Term Where* -> AttributeNameValue {cons("AttributeDefTerm")}
    
    %% Attribute definition blocks/groups
    DefType Id* Pattern       ":" NameDefBlockDef+    -> RuleDef {cons("NameDefBlock")}
    DefType Id* AttributeDecl ":" PatternDefBlockDef+ -> RuleDef {cons("PatternDefBlock")}
    
    %% Definitions grouped in a NameDefBlock
    ChildDot AttributeDecl ":=" Term     Where* -> NameDefBlockDef {cons("AttributeDefTerm")}
    ChildDot AttributeDecl "="  Strategy        -> NameDefBlockDef {cons("AttributeDefStrategy")}

    %% Definitions grouped in a PatternDefBlock
    Pattern OptDotChild "->" ResultTerm NoWhere* -> PatternDefBlockDef {cons("AttributePDefTerm")}
    Pattern OptDotChild "->" Term       Where*   -> PatternDefBlockDef {cons("AttributePDefTerm")}

    "where" Strategy -> Where {cons("WhereClause")}
    "with" Strategy  -> Where {cons("WithClause")}
    UNDEFINED        -> NoWhere

  context-free syntax %% Misc.
    
    "eq" Pattern "->" Term Where* -> RuleDef {cons("AnonymousRewriteRule")}
      
    "id"   -> PreTerm {cons("IdTerm")}
    "fail" -> Term {cons("FailTerm")}

  context-free syntax

    %%  Either reject suffices, but the first may be too specific/confusing
    %%  "<" Strategy ">" AttributeKeyword -> Term {reject}
    AttributeKeyword -> Var {reject}
  
  lexical syntax
    
    "eq"        -> AttributeKeyword
    "def"       -> AttributeKeyword
    "decorator" -> AttributeKeyword
  
  context-free restrictions
  
    "eq"
    "def"
    "root"
    "decorator"
    "attributes" -/- [a-zA-Z0-9\'\-\_]

